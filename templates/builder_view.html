<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRPG Builder - 8-Bit Edition</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dalgona/neodgm/neodgm.css">

    <style>
        :root {
            /* 8-Bit Night Palette */
            --bg-night-start: #0B0B19;
            --bg-night-end: #1A0B2E;
            --pixel-border: #4A4A6A;
            --pixel-border-light: #6A6A8A;
            --text-main: #E0E0E0;
            --text-accent: #FFFACD; /* Lemon Chiffon (Star color) */
            --color-primary: #6366f1; /* Indigo */
            --color-danger: #FF007F; /* Deep Pink */
            --color-success: #00FFFF; /* Cyan */
        }

        body {
            font-family: 'NeoDunggeunmo', sans-serif;
            background-color: var(--bg-night-start);
            color: var(--text-main);
            overflow: hidden;
            margin: 0;
        }

        .font-pixel { font-family: 'Press Start 2P', cursive; }

        /* CRT Effect */
        .crt-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 9999;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker { 0% { opacity: 0.97; } 50% { opacity: 0.95; } 100% { opacity: 0.97; } }

        /* Retro Scrollbar */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-night-start); border: 2px solid var(--pixel-border); }
        ::-webkit-scrollbar-thumb { background: var(--pixel-border); border: 1px solid var(--bg-night-start); }
        ::-webkit-scrollbar-thumb:hover { background: var(--pixel-border-light); }

        /* Pixel Borders (Box Shadow Hack for sharp corners) */
        .pixel-box {
            background-color: rgba(19, 19, 32, 0.95);
            box-shadow:
                -2px 0 0 0 var(--pixel-border),
                2px 0 0 0 var(--pixel-border),
                0 -2px 0 0 var(--pixel-border),
                0 2px 0 0 var(--pixel-border);
            margin: 2px;
        }
        .pixel-box-sm {
            box-shadow: 0 0 0 2px var(--pixel-border);
        }

        /* Buttons & Inputs */
        .pixel-btn {
            font-family: 'NeoDunggeunmo', sans-serif;
            border: 2px solid var(--pixel-border);
            background: var(--bg-night-end);
            color: var(--text-accent);
            /* text-transform: uppercase; 한글이라 제거 */
            transition: all 0.1s;
            box-shadow: 2px 2px 0px 0px rgba(0,0,0,0.5);
        }
        .pixel-btn:hover {
            background: var(--pixel-border);
            transform: translate(-1px, -1px);
            box-shadow: 3px 3px 0px 0px rgba(0,0,0,0.5);
        }
        .pixel-btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        .pixel-input {
            background: #050510;
            border: 2px solid var(--pixel-border);
            color: white;
            font-family: 'NeoDunggeunmo', sans-serif;
            outline: none;
        }
        .pixel-input:focus {
            border-color: var(--text-accent);
        }

        /* Graph Elements */
        .bg-dots-pattern {
            background-image:
                radial-gradient(var(--pixel-border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .connection-line { stroke: var(--pixel-border-light); stroke-width: 2; fill: none; transition: stroke 0.2s; }
        .connection-line:hover { stroke: var(--text-accent); stroke-width: 4; cursor: pointer; }
        .connecting-line { stroke: var(--color-success); stroke-width: 3; stroke-dasharray: 8,4; fill: none; animation: dash 0.5s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -12; } }

        /* Node Styling */
        .node-ui {
            background: #1A0B2E;
            border: 2px solid var(--pixel-border);
            box-shadow: 4px 4px 0px 0px rgba(0,0,0,0.5);
            transition: border-color 0.1s;
        }
        .node-ui:hover { border-color: var(--text-accent); z-index: 50; }
        .node-ui.selected { border-color: var(--color-success); box-shadow: 0 0 0 2px var(--color-success), 4px 4px 0px 0px rgba(0,0,0,0.5); z-index: 50; }

        /* [추가] 연결 대상 후보 스타일 (커서 변경) */
        .node-ui.connecting-target-candidate:hover {
            border-color: var(--color-success);
            cursor: crosshair !important;
        }
        .node-ui.connecting-source { border-color: var(--color-danger); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 127, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 0, 127, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 127, 0); } }

        .animate-fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body>
    <div class="crt-overlay"></div>
    <div id="root" class="w-full h-full relative z-10"></div>

    {% raw %}
    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        // --- llm_factory.py 기반 AI 모델 리스트 ---
        const AVAILABLE_AI_MODELS = [
            // Google
            { id: "openai/google/gemini-2.0-flash-001", name: "Gemini 2.0 Flash", provider: "Google" },
            { id: "openai/google/gemini-2.5-flash-lite", name: "Gemini 2.5 Flash Lite", provider: "Google" },
            { id: "openai/google/gemini-2.5-flash", name: "Gemini 2.5 Flash", provider: "Google" },
            { id: "openai/google/gemini-3-flash-preview", name: "Gemini 3 Flash (Preview)", provider: "Google" },
            { id: "openai/google/gemini-3-pro-preview", name: "Gemini 3 Pro (Preview)", provider: "Google" },

            // Anthropic
            { id: "openai/anthropic/claude-3.5-haiku", name: "Claude 3.5 Haiku", provider: "Anthropic" },
            { id: "openai/anthropic/claude-3.5-sonnet", name: "Claude 3.5 Sonnet", provider: "Anthropic" },
            { id: "openai/anthropic/claude-sonnet-4", name: "Claude Sonnet 4", provider: "Anthropic" },
            { id: "openai/anthropic/claude-haiku-4.5", name: "Claude Haiku 4.5", provider: "Anthropic" },
            { id: "openai/anthropic/claude-sonnet-4.5", name: "Claude Sonnet 4.5", provider: "Anthropic" },
            { id: "openai/anthropic/claude-opus-4.5", name: "Claude Opus 4.5", provider: "Anthropic" },

            // OpenAI
            { id: "openai/openai/gpt-4o-mini", name: "GPT-4o Mini", provider: "OpenAI" },
            { id: "openai/openai/gpt-4o", name: "GPT-4o", provider: "OpenAI" },
            { id: "openai/openai/gpt-5-mini", name: "GPT-5 Mini", provider: "OpenAI" },
            { id: "openai/openai/gpt-5.2", name: "GPT-5.2", provider: "OpenAI" },

            // DeepSeek
            { id: "openai/tngtech/deepseek-r1t2-chimera:free", name: "R1 Chimera (Free)", provider: "DeepSeek" },
            { id: "openai/deepseek/deepseek-chat-v3-0324", name: "DeepSeek Chat V3", provider: "DeepSeek" },
            { id: "openai/deepseek/deepseek-v3.2", name: "DeepSeek V3.2", provider: "DeepSeek" },

            // Meta Llama
            { id: "openai/meta-llama/llama-3.1-8b-instruct", name: "Llama 3.1 8B", provider: "Meta" },
            { id: "openai/meta-llama/llama-3.1-405b-instruct:free", name: "Llama 3.1 405B (Free)", provider: "Meta" },
            { id: "openai/meta-llama/llama-3.1-405b-instruct", name: "Llama 3.1 405B", provider: "Meta" },
            { id: "openai/meta-llama/llama-3.3-70b-instruct:free", name: "Llama 3.3 70B (Free)", provider: "Meta" },
            { id: "openai/meta-llama/llama-3.3-70b-instruct", name: "Llama 3.3 70B", provider: "Meta" },

            // xAI Grok
            { id: "openai/x-ai/grok-code-fast-1", name: "Grok Code Fast 1", provider: "xAI" },
            { id: "openai/x-ai/grok-4-fast", name: "Grok 4 Fast", provider: "xAI" },
            { id: "openai/x-ai/grok-4.1-fast", name: "Grok 4.1 Fast", provider: "xAI" },

            // Mistral & Xiaomi
            { id: "openai/mistralai/devstral-2512:free", name: "Devstral 2512 (Free)", provider: "Mistral" },
            { id: "openai/xiaomi/mimo-v2-flash:free", name: "MiMo V2 Flash (Free)", provider: "Xiaomi" }
        ];

        // --- 아이콘 (굵게, Memoized) ---
        const Icon = React.memo(({ name, size = 18, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (!window.lucide || !ref.current) return;
                ref.current.innerHTML = '';
                const i = document.createElement('i');
                i.setAttribute('data-lucide', name);
                ref.current.appendChild(i);
                window.lucide.createIcons({
                    root: ref.current,
                    nameAttr: 'data-lucide',
                    attrs: { width: size, height: size, class: className, "stroke-width": 3 }
                });
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', alignItems: 'center', justifyContent: 'center' }}></span>;
        });

        // --- [최적화] Node Item Component ---
        const NodeItem = React.memo(({ node, isSelected, isConnectSource, isCandidate, onMouseDown, onClick, onLinkClick, onDelete, onAudit, globalNpcs, globalEnemies, addEntityToNode, removeEntityFromNode }) => {
            const handleBodyClick = (e) => {
                // Only allow node selection, not connection
                if (onClick) onClick(e, node.id);
            };

            return (
                <div style={{ left: node.x, top: node.y }}
                     onMouseDown={(e) => onMouseDown(e, node.id)}
                     onClick={handleBodyClick}
                     className={`node-ui absolute w-[200px] flex flex-col group
                        ${isSelected ? 'selected' : ''}
                        ${isConnectSource ? 'connecting-source' : ''}
                        ${isCandidate ? 'connecting-target-candidate' : ''}`}>

                    <div className="p-2 border-b-2 border-[#4A4A6A] bg-[#0B0B19] flex justify-between items-center cursor-grab active:cursor-grabbing">
                        <span className="text-[10px] text-[#FFFACD] flex items-center gap-1 font-bold">
                            {node.type==='start' && <Icon name="settings" size={10}/>}
                            {node.type==='scene' && <Icon name="clapperboard" size={10}/>}
                            {node.type==='ending' && <Icon name="flag" size={10}/>}
                            {node.type.toUpperCase()}
                        </span>
                        <button
                            onMouseDown={(e) => e.stopPropagation()}
                            onClick={(e) => onLinkClick(e, node.id)}
                            className={`p-1 hover:text-[#00FFFF] transition-colors ${isConnectSource ? 'text-[#00FFFF] animate-pulse' : 'text-[#6A6A8A]'}`}
                            title="연결 모드 시작 (클릭 후 다른 노드 클릭)">
                            <Icon name="link" size={12}/>
                        </button>
                    </div>
                    <div className="p-3 min-h-[60px] bg-[#1A0B2E]">
                        <div className="font-bold mb-1 truncate text-white text-xs">{node.data.title || '제목 없음'}</div>
                        <div className="text-[10px] text-[#9A9AAA] line-clamp-2 leading-relaxed">{node.data.description || '내용 없음'}</div>
                    </div>
                </div>
            );
        }, (prev, next) => {
            return (
                prev.node === next.node &&
                prev.isSelected === next.isSelected &&
                prev.isConnectSource === next.isConnectSource &&
                prev.isCandidate === next.isCandidate &&
                prev.globalNpcs === next.globalNpcs &&
                prev.globalEnemies === next.globalEnemies
            );
        });

        // --- [최적화] Edge Layer Component ---
        const EdgeLayer = React.memo(({ edges, nodes, connectSource, mousePos }) => {
            return (
                <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible">
                    {edges.map(e => {
                        const s = nodes.find(n => n.id === e.source), t = nodes.find(n => n.id === e.target);
                        if(!s || !t) return null;
                        return <line key={e.id} x1={s.x+100} y1={s.y+40} x2={t.x+100} y2={t.y+40} className="connection-line" />;
                    })}
                    {connectSource && (() => {
                        const s = nodes.find(n => n.id === connectSource);
                        if(s) return <line x1={s.x+100} y1={s.y+40} x2={mousePos.x} y2={mousePos.y} className="connecting-line" stroke="#00FFFF" />;
                    })()}
                </svg>
            );
        });

        // --- 픽셀 모달 ---
        const Modal = ({ isOpen, title, onClose, children, footer }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-fade-in p-4">
                    <div className="pixel-box w-full max-w-2xl max-h-[85vh] flex flex-col bg-[#131320] border-2 border-[#4A4A6A]">
                        <div className="p-4 border-b-2 border-[#4A4A6A] flex justify-between items-center bg-[#1A0B2E]">
                            <h3 className="text-[#FFFACD] flex items-center gap-2 text-sm font-bold">{title}</h3>
                            <button onClick={onClose} className="text-[#4A4A6A] hover:text-[#FF007F] transition-colors"><Icon name="x" size={24}/></button>
                        </div>
                        <div className="p-6 overflow-y-auto custom-scrollbar flex-1 space-y-4">
                            {children}
                        </div>
                        {footer && <div className="p-4 border-t-2 border-[#4A4A6A] bg-[#0B0B19] flex justify-end gap-2">{footer}</div>}
                    </div>
                </div>
            );
        };

        // --- 컨버터 (Legacy 호환) ---
        const convertScenesToNodes = (scenData) => {
            const nodes = [], edges = [];
            let yOffset = 50; const xBase = 400;

            nodes.push({
                id: 'start', type: 'start', x: 50, y: 50,
                data: { label: scenData.title || '시나리오 설정', prologue: scenData.prologue || '', gm_notes: scenData.gm_notes || '', background: scenData.background || '' }
            });

            (scenData.scenes || []).forEach((s, idx) => {
                nodes.push({
                    id: s.scene_id, type: 'scene', x: xBase, y: yOffset + (idx * 200),
                    data: {
                        title: s.title || s.name || s.scene_id, description: s.description || '', background: s.background || '',
                        trigger: s.trigger || '', ai_note: s.ai_note || '',
                        npcs: (s.npcs || []).map(n => typeof n === 'string' ? {name:n} : n),
                        enemies: (s.enemies || []).map(e => typeof e === 'string' ? {name:e} : e)
                    }
                });
            });

            const endingYStart = yOffset + ((scenData.scenes || []).length * 200);
            (scenData.endings || []).forEach((e, idx) => {
                nodes.push({
                    id: e.ending_id, type: 'ending', x: xBase + 400, y: endingYStart + (idx * 200),
                    data: { title: e.title || '엔딩', description: e.description || '', background: e.background || '', ai_note: e.ai_note || '' }
                });
            });

            (scenData.prologue_connects_to || []).forEach(targetId => edges.push({ id: `e-start-${targetId}`, source: 'start', target: targetId }));
            (scenData.scenes || []).forEach(s => {
                (s.transitions || []).forEach((t, i) => {
                    if (t.target_scene_id) edges.push({ id: `e-${s.scene_id}-${t.target_scene_id}-${i}`, source: s.scene_id, target: t.target_scene_id });
                });
            });
            return { nodes, edges };
        };

        // --- 메인 컴포넌트 ---
        function ScenarioBuilder() {
            // Data State
            const [nodes, setNodes] = useState([
                { id: 'start', type: 'start', x: 50, y: 50, data: { label: '시나리오 설정', prologue: '', gm_notes: '', background: '' } },
                { id: 'scene-1', type: 'scene', x: 400, y: 150, data: { title: '첫 번째 장면', description: '', background: '', trigger: '', npcs: [], enemies: [] } }
            ]);
            const [edges, setEdges] = useState([]);
            const [globalNpcs, setGlobalNpcs] = useState([]);
            const [globalEnemies, setGlobalEnemies] = useState([]);

            // UI State
            const [isEditMode, setIsEditMode] = useState(false);
            const [scenarioId, setScenarioId] = useState(null);
            const [isDraft, setIsDraft] = useState(false);
            const [isGenerating, setIsGenerating] = useState(false);

            // Canvas State
            const [pan, setPan] = useState({ x: 0, y: 0, zoom: 1 });
            const [isPanning, setIsPanning] = useState(false);
            const [dragNode, setDragNode] = useState(null);

            // [State] 연결 로직 (Source Node ID)
            const [connectSource, setConnectSource] = useState(null);

            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [selectedNodeId, setSelectedNodeId] = useState(null);
            const canvasRef = useRef(null);

            // Modals & Misc
            const [modals, setModals] = useState({ npcGen: false, npcList: false, presetLoad: false, scenarioList: false, imageGen: false });
            const [toast, setToast] = useState({ show: false, msg: '', type: 'info' });
            const [auditState, setAuditState] = useState({ isOpen: false, isLoading: false, results: null, targetNodeId: null });
            const [imageGenState, setImageGenState] = useState({ isLoading: false, result: null });
            const [presetList, setPresetList] = useState([]);
            const [dbNpcList, setDbNpcList] = useState([]);
            const [userScenarios, setUserScenarios] = useState([]);

            // AI 모델 선택
            const [selectedModel, setSelectedModel] = useState('openai/tngtech/deepseek-r1t2-chimera:free');

            const [history, setHistory] = useState({ past: [], future: [] });

            // History
            const pushHistory = useCallback(() => {
                setHistory(curr => ({
                    past: [...curr.past, { nodes: JSON.parse(JSON.stringify(nodes)), edges: JSON.parse(JSON.stringify(edges)) }],
                    future: []
                }));
            }, [nodes, edges]);

            const undo = () => {
                if (history.past.length === 0) return;
                const previous = history.past[history.past.length - 1];
                const newPast = history.past.slice(0, -1);
                setHistory({ past: newPast, future: [{ nodes, edges }, ...history.future] });
                setNodes(previous.nodes); setEdges(previous.edges);
            };
            const redo = () => {
                if (history.future.length === 0) return;
                const next = history.future[0];
                const newFuture = history.future.slice(1);
                setHistory({ past: [...history.past, { nodes, edges }], future: newFuture });
                setNodes(next.nodes); setEdges(next.edges);
            };

            // Init Load
            useEffect(() => {
                const path = window.location.pathname;
                const match = path.match(/\/views\/scenes\/edit\/(\d+)/);
                if (match) {
                    const sid = match[1];
                    setScenarioId(sid); setIsEditMode(true); loadScenarioData(sid);
                }
            }, []);

            const loadScenarioData = async (sid) => {
                try {
                    let res = await fetch(`/api/draft/${sid}`);
                    let data = await res.json();
                    if (!data.success || !data.scenario) {
                        res = await fetch(`/api/scenario/${sid}/edit`);
                        data = await res.json();
                        if(data.data) data = { success: true, scenario: data.data.scenario };
                    } else setIsDraft(data.is_draft);

                    if (data.scenario) {
                        const scen = data.scenario;
                        let loadedNodes = scen.nodes, loadedEdges = scen.edges;
                        if ((!loadedNodes || loadedNodes.length === 0) && scen.scenes) {
                            const converted = convertScenesToNodes(scen);
                            loadedNodes = converted.nodes; loadedEdges = converted.edges;
                        }
                        // Normalize
                        if(loadedNodes) loadedNodes = loadedNodes.map(n => {
                            if(n.data) {
                                if(n.data.npcs) n.data.npcs = n.data.npcs.map(x => typeof x === 'string' ? {name: x} : x);
                                if(n.data.enemies) n.data.enemies = n.data.enemies.map(x => typeof x === 'string' ? {name: x} : x);
                            }
                            return n;
                        });

                        setNodes(loadedNodes || []); setEdges(loadedEdges || []);
                        setGlobalNpcs(scen.npcs?.filter(n => !n.isEnemy) || []);
                        setGlobalEnemies(scen.npcs?.filter(n => n.isEnemy) || []);
                        showToast("시나리오 로드 완료", "success");
                    }
                } catch (e) { showToast("로드 실패: " + e.message, "error"); }
            };

            // Actions
            const addNode = (type) => {
                pushHistory();
                const id = `${type}-${Date.now()}`;
                const newData = type === 'scene'
                    ? { title: '새 장면', description: '', trigger: '', ai_note: '', npcs: [], enemies: [] }
                    : { title: '새 엔딩', description: '', ai_note: '' };
                setNodes(prev => [...prev, { id, type, x: -pan.x/pan.zoom + 200, y: -pan.y/pan.zoom + 200, data: newData }]);
            };

            const deleteNode = useCallback((id) => {
                if (id === 'start') return showToast("시작 노드는 삭제할 수 없습니다.", "error");
                if (edges.some(e => e.source === id || e.target === id) && !confirm("연결된 선이 있습니다. 삭제하시겠습니까?")) return;
                pushHistory();
                setNodes(prev => prev.filter(n => n.id !== id));
                setEdges(prev => prev.filter(e => e.source !== id && e.target !== id));
                setSelectedNodeId(null);
            }, [edges, pushHistory]);

            const updateNodeData = useCallback((id, key, value) => {
                setNodes(prev => prev.map(n => n.id === id ? { ...n, data: { ...n.data, [key]: value } } : n));
            }, []);

            // [변경] 연결 로직 (Source 클릭 -> Target 클릭)
            const handleLinkClick = useCallback((e, nodeId) => {
                e.stopPropagation();

                if (connectSource === null) {
                    // 1단계: 시작점 선택
                    setConnectSource(nodeId);
                    showToast("연결할 대상 노드를 클릭하세요 (취소: 배경 클릭)", "info");
                } else {
                    // 2단계: 도착점 선택 (자기 자신 클릭 시 취소)
                    if (connectSource === nodeId) {
                        setConnectSource(null);
                        showToast("연결 취소", "info");
                    } else {
                        // 연결 생성
                        if (!edges.some(eg => eg.source === connectSource && eg.target === nodeId)) {
                            pushHistory();
                            setEdges(prev => [...prev, { id: `e-${Date.now()}`, source: connectSource, target: nodeId }]);
                            showToast("연결되었습니다!", "success");
                        } else {
                            showToast("이미 연결되어 있습니다.", "warning");
                        }
                        setConnectSource(null);
                    }
                }
            }, [connectSource, edges, pushHistory]);

            // 캔버스 배경 클릭 시 연결 취소
            const handleCanvasClick = (e) => {
                if (connectSource && !e.target.closest('.node-ui')) {
                    setConnectSource(null);
                    showToast("연결 대기 취소됨", "info");
                }
            };

            // Canvas Interaction
            const handleMouseDown = useCallback((e) => {
                if (e.target.closest('.node-ui')) return;
                if (e.button === 0 || e.button === 1) setIsPanning(true);
            }, []);

            const handleMouseMove = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left - pan.x) / pan.zoom;
                const y = (e.clientY - rect.top - pan.y) / pan.zoom;
                setMousePos({ x, y });

                if (isPanning) {
                    setPan(p => ({ ...p, x: p.x + e.movementX, y: p.y + e.movementY }));
                } else if (dragNode) {
                    setNodes(prev => prev.map(n => n.id === dragNode ? { ...n, x, y } : n));
                }
            }, [isPanning, dragNode, pan]);

            const handleMouseUp = () => {
                if (dragNode) pushHistory();
                setIsPanning(false); setDragNode(null);
            };

            const handleNodeDragStart = useCallback((e, id) => {
                // 연결 모드일 때는 드래그 방지
                if (connectSource) return;
                setDragNode(id); setSelectedNodeId(id);
            }, [connectSource]);

            // Helpers
            const showToast = (msg, type) => {
                setToast({ show: true, msg, type });
                setTimeout(() => setToast({ show: false, msg: '', type: 'info' }), 3000);
            };

            const addEntityToNode = useCallback((id, key, entity) => {
                setNodes(prev => prev.map(n => {
                    if (n.id === id) {
                        const list = n.data[key] || [];
                        if (list.some(e => e.name === entity.name)) return n;
                        return { ...n, data: { ...n.data, [key]: [...list, entity] } };
                    } return n;
                }));
            }, []);

            const removeEntityFromNode = useCallback((id, key, idx) => {
                setNodes(prev => prev.map(n => n.id === id ? { ...n, data: { ...n.data, [key]: (n.data[key]||[]).filter((_,i)=>i!==idx) } } : n));
            }, []);

            // API Calls
            const saveDraft = async () => {
                if (!scenarioId) return;
                try {
                    await fetch(`/api/draft/${scenarioId}/save`, {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ nodes, edges, npcs: [...globalNpcs, ...globalEnemies] })
                    });
                    setIsDraft(true); showToast("저장 완료", "success");
                } catch(e) { showToast("저장 실패", "error"); }
            };
            const publishScenario = async () => {
                if(!confirm("반영하시겠습니까?")) return;
                try {
                    await fetch(`/api/draft/${scenarioId}/publish`, { method: 'POST' });
                    setIsDraft(false); showToast("반영 완료", "success");
                } catch(e) { showToast("반영 실패", "error"); }
            };
            const generateNewScenario = async () => {
                if (nodes.length < 2) return showToast("최소 2개의 노드 필요", "error");
                setIsGenerating(true);
                try {
                    const res = await fetch('/api/init_game', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ nodes, edges, npcs: [...globalNpcs, ...globalEnemies], model: selectedModel, title: nodes[0].data.label })
                    });
                    const json = await res.json();
                    if(json.filename) window.location.href = `/views/scenes/edit/${json.filename}`;
                    else throw new Error(json.error);
                } catch(e) { showToast(e.message, "error"); setIsGenerating(false); }
            };
            const runAiAudit = async (nodeId = null) => {
                setAuditState({ isOpen: true, isLoading: true, results: null, targetNodeId: nodeId });
                try {
                    const res = await fetch('/api/audit/scene', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ scenario: { nodes, edges }, scene_id: nodeId, model: selectedModel })
                    });
                    const json = await res.json();
                    if(json.success && json.result) {
                        const r = json.result;
                        const issues = [...(r.coherence?.issues||[]), ...(r.trigger?.issues||[])];
                        setAuditState(prev => ({ ...prev, isLoading: false, results: { issues, summary: json.summary } }));
                    } else throw new Error(json.error);
                } catch(e) { showToast("검수 실패", "error"); setAuditState(p=>({...p, isOpen:false})); }
            };
            const applySuggestion = (issue) => {
                if (!issue.scene_id) return;
                const targetId = issue.scene_id;
                const suggestionText = `\n[${new Date().toLocaleTimeString()} AI 제안]\n문제: ${issue.message}\n제안: ${issue.suggestion}\n`;
                setNodes(prev => prev.map(n => {
                    if (n.id === targetId || n.data.title === targetId) {
                        return { ...n, data: { ...n.data, ai_note: (n.data.ai_note || "") + suggestionText } };
                    }
                    return n;
                }));
                showToast(`"${targetId}" 씬의 AI 노트에 추가됨`, "success");
            };

            // AI 이미지 생성 함수
            const generateImage = async (imageType, description) => {
                setImageGenState({ isLoading: true, result: null });
                try {
                    const res = await fetch('/api/image/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_type: imageType,
                            description: description,
                            scenario_id: scenarioId ? parseInt(scenarioId) : null,
                            target_id: selectedNodeId
                        })
                    });
                    
                    const json = await res.json();
                    if (json.success && json.data) {
                        setImageGenState({ isLoading: false, result: json.data });
                        showToast("이미지 생성 완료!", "success");
                        
                        // 생성된 이미지 URL을 노드 데이터에 저장
                        if (selectedNodeId) {
                            const imageKey = imageType === 'background' ? 'background_image' : 
                                           imageType === 'npc' ? 'npc_image' : 'enemy_image';
                            updateNodeData(selectedNodeId, imageKey, json.data.image_url);
                        }
                    } else {
                        throw new Error(json.error || '이미지 생성 실패');
                    }
                } catch (e) {
                    showToast("이미지 생성 실패: " + e.message, "error");
                    setImageGenState({ isLoading: false, result: null });
                }
            };
            const loadPreset = (preset) => {
                if(!confirm("현재 내용이 사라집니다. 적용하시겠습니까?")) return;
                try {
                    let data = typeof preset.data === 'string' ? JSON.parse(preset.data) : preset.data;
                    pushHistory();
                    setNodes(data.nodes); setEdges(data.edges);
                    setModals(m=>({...m, presetLoad:false})); showToast("프리셋 적용됨", "success");
                } catch(e) { showToast("프리셋 오류", "error"); }
            };

            return (
                <div className="flex h-screen overflow-hidden text-sm font-sans"
                     onMouseUp={handleMouseUp} onMouseMove={handleMouseMove} onClick={handleCanvasClick}
                     onContextMenu={e => { e.preventDefault(); setConnectSource(null); }}>

                    {/* Background Layer with Dark Night Gradient */}
                    <div className="absolute inset-0 z-0 bg-dots-pattern pointer-events-none"></div>

                    {/* Loading Overlay */}
                    {isGenerating && (
                        <div className="fixed inset-0 z-[200] bg-black/90 backdrop-blur-sm flex flex-col items-center justify-center text-white animate-fade-in">
                            <div className="w-16 h-16 border-4 border-[#00FFFF] border-t-transparent rounded-none animate-spin mb-4"></div>
                            <div className="text-xl font-bold">시나리오 생성 중...</div>
                        </div>
                    )}

                    {/* Toast */}
                    {toast.show && (
                        <div className={`fixed top-5 left-1/2 -translate-x-1/2 z-[200] px-6 py-3 border-2 border-[#4A4A6A] shadow-xl font-bold animate-fade-in bg-[#131320] text-[#FFFACD]`}>
                            {toast.msg}
                        </div>
                    )}

                    {/* Left Toolbar */}
                    <div className="w-64 bg-[#0B0B19] border-r-2 border-[#4A4A6A] flex flex-col z-20 shadow-2xl">
                        <div className="p-4 border-b-2 border-[#4A4A6A] flex items-center justify-between bg-[#1A0B2E]">
                            <span className="font-bold text-sm text-[#FF007F]">TRPG 빌더</span>
                            <a href="/" className="text-[#6A6A8A] hover:text-[#FFFACD]"><Icon name="home"/></a>
                        </div>
                        <div className="p-4 space-y-3 overflow-y-auto flex-1 custom-scrollbar">
                            <div className="text-[10px] text-[#6A6A8A] mb-1 font-bold">노드 생성</div>
                            <button onClick={() => addNode('scene')} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-xs"><Icon name="plus-square"/> Scene 추가</button>
                            <button onClick={() => addNode('ending')} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-xs text-[#FF007F]"><Icon name="flag"/> Ending 추가</button>

                            <div className="h-px bg-[#4A4A6A] my-2"></div>
                            <div className="text-[10px] text-[#6A6A8A] mb-1 font-bold">에셋 관리</div>
                            <button onClick={() => setModals(m => ({ ...m, npcGen: true }))} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-xs text-[#00FFFF]"><Icon name="user-plus"/> NPC 생성</button>
                            <button onClick={async () => { try { const res = await fetch('/api/npc/list'); const data = await res.json(); setDbNpcList(data); setModals(m=>({...m, npcList:true})); } catch(e){} }} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-xs"><Icon name="users"/> NPC 불러오기</button>

                            <div className="h-px bg-[#4A4A6A] my-2"></div>
                            <div className="text-[10px] text-[#6A6A8A] mb-1 font-bold">도구</div>
                            <div className="flex gap-2">
                                <button onClick={undo} className="pixel-btn flex-1 py-2 text-[#6A6A8A]" title="되돌리기"><Icon name="undo-2"/></button>
                                <button onClick={redo} className="pixel-btn flex-1 py-2 text-[#6A6A8A]" title="다시하기"><Icon name="redo-2"/></button>
                            </div>
                            <button onClick={async () => { try { const res = await fetch('/api/presets'); const data = await res.json(); setPresetList(data); setModals(m=>({...m, presetLoad:true})); } catch(e){} }} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-xs mt-2"><Icon name="folder-open"/> 프리셋 로드</button>
                            <button onClick={async () => { try { const res = await fetch('/api/scenarios/data?filter=my'); const data = await res.json(); setUserScenarios(data); setModals(m=>({...m, scenarioList:true})); } catch(e){} }} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-xs mt-2"><Icon name="file-edit"/> 시나리오 로드</button>
                        </div>
                        <div className="p-4 border-t-2 border-[#4A4A6A] bg-[#0B0B19]">
                            {/* [추가] AI 모델 선택 드롭다운 */}
                            <div className="mb-3">
                                <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">AI 모델 선택</label>
                                <select value={selectedModel} onChange={e => setSelectedModel(e.target.value)}
                                        className="w-full pixel-input p-1 text-xs">
                                    {AVAILABLE_AI_MODELS.map(model => (
                                        <option key={model.id} value={model.id}>
                                            {model.name}
                                        </option>
                                    ))}
                                </select>
                            </div>

                            <button onClick={() => runAiAudit(null)} className="pixel-btn w-full mb-3 py-3 text-xs flex items-center justify-center gap-2 border-[#6366f1] text-[#6366f1] hover:text-white hover:bg-[#6366f1]">
                                <Icon name="brain-circuit"/> 전체 스토리 검수
                            </button>
                            {!isEditMode ? (
                                <button onClick={generateNewScenario} className="pixel-btn w-full py-3 flex items-center justify-center gap-2 bg-[#00FFFF]/10 text-[#00FFFF] border-[#00FFFF]"><Icon name="play"/> 게임 시작</button>
                            ) : (
                                <div className="space-y-2">
                                    <button onClick={saveDraft} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-[#6366f1]"><Icon name="save"/> 임시 저장</button>
                                    <button onClick={publishScenario} className="pixel-btn w-full py-2 flex items-center justify-center gap-2 text-[#00FFFF]"><Icon name="upload"/> 최종 반영</button>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Canvas */}
                    <div ref={canvasRef} className="flex-1 relative overflow-hidden cursor-crosshair z-10"
                         onMouseDown={handleMouseDown}
                         onWheel={(e) => setPan(p => ({ ...p, zoom: Math.min(Math.max(0.2, p.zoom - e.deltaY * 0.001), 3) }))}>

                        <div style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${pan.zoom})`, transformOrigin: '0 0', width: '100%', height: '100%' }}>
                            {/* Edges */}
                            <EdgeLayer edges={edges} nodes={nodes} connectSource={connectSource} mousePos={mousePos} />

                            {/* Nodes */}
                            {nodes.map(node => (
                                <NodeItem
                                    key={node.id}
                                    node={node}
                                    isSelected={selectedNodeId === node.id}
                                    isConnectSource={connectSource === node.id}
                                    isCandidate={connectSource && connectSource !== node.id}
                                    onMouseDown={handleNodeDragStart}
                                    onClick={handleLinkClick}
                                    onLinkClick={handleLinkClick}
                                    onDelete={deleteNode}
                                    onAudit={runAiAudit}
                                    globalNpcs={globalNpcs}
                                    globalEnemies={globalEnemies}
                                    addEntityToNode={addEntityToNode}
                                    removeEntityFromNode={removeEntityFromNode}
                                />
                            ))}
                        </div>

                        {/* Controls */}
                        <div className="absolute top-4 right-4 flex flex-col gap-2 z-30">
                             <button onClick={() => setPan(p=>({...p, zoom: p.zoom+0.1}))} className="pixel-btn p-2 bg-[#0B0B19]"><Icon name="plus"/></button>
                             <button onClick={() => setPan({x:0, y:0, zoom:1})} className="pixel-btn p-2 bg-[#0B0B19] text-xs font-bold">{Math.round(pan.zoom*100)}%</button>
                             <button onClick={() => setPan(p=>({...p, zoom: p.zoom-0.1}))} className="pixel-btn p-2 bg-[#0B0B19]"><Icon name="minus"/></button>
                        </div>

                        {isEditMode && (
                            <div className="absolute top-4 left-4 pixel-box px-4 py-2 flex items-center gap-2 z-30 bg-[#0B0B19]">
                                <span className="w-2 h-2 bg-[#10b981] animate-pulse"></span>
                                <span className="text-xs text-[#FFFACD] font-bold">편집 중: {scenarioId}</span>
                            </div>
                        )}

                        {connectSource && (
                            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 pixel-box px-6 py-2 bg-[#0B0B19] text-[#00FFFF] text-xs animate-bounce z-50 border-2 border-[#00FFFF]">
                                연결할 대상을 클릭하세요...
                            </div>
                        )}
                    </div>

                    {/* Right Properties Panel */}
                    <div className="w-80 bg-[#131320] border-l-2 border-[#4A4A6A] p-4 overflow-y-auto custom-scrollbar z-20 shadow-xl">
                        {selectedNodeId ? (() => {
                            const node = nodes.find(n => n.id === selectedNodeId);
                            if(!node) return null;
                            const isStart = node.type === 'start';
                            return (
                                <div className="space-y-4 animate-fade-in">
                                    <div className="text-xs text-[#6A6A8A] border-b-2 border-[#4A4A6A] pb-2 mb-4 flex justify-between font-bold">
                                        속성 편집 <span>ID: {node.id.split('-')[1] || node.id}</span>
                                    </div>

                                    <div>
                                        <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">제목</label>
                                        <input className="w-full pixel-input p-2 text-sm"
                                               value={node.data.title || node.data.label || ''}
                                               onChange={e => updateNodeData(node.id, isStart?'label':'title', e.target.value)} />
                                    </div>

                                    <div>
                                        <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">내용/지문</label>
                                        <textarea className="w-full pixel-input p-2 text-sm h-32 resize-none"
                                                  value={node.data.description || node.data.prologue || ''}
                                                  onChange={e => updateNodeData(node.id, isStart?'prologue':'description', e.target.value)}></textarea>
                                    </div>

                                    {node.type === 'scene' && (
                                        <>
                                            <div>
                                                <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">진입 조건 (Trigger)</label>
                                                <input className="w-full pixel-input p-2 text-sm"
                                                       value={node.data.trigger || ''} placeholder="예: 문을 연다"
                                                       onChange={e => updateNodeData(node.id, 'trigger', e.target.value)} />
                                            </div>

                                            <div className="pt-2 border-t border-[#4A4A6A] mt-2">
                                                <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">등장 NPC</label>
                                                <div className="space-y-1 mb-2">
                                                    {(node.data.npcs||[]).map((n,i) => (
                                                        <div key={i} className="flex justify-between p-1 bg-[#0B0B19] border border-[#4A4A6A] text-xs text-[#10b981]">
                                                            {n.name} <button onClick={()=>removeEntityFromNode(node.id,'npcs',i)}><Icon name="x" size={12}/></button>
                                                        </div>
                                                    ))}
                                                </div>
                                                <select className="w-full pixel-input p-1 text-xs" onChange={(e)=>{if(e.target.value){addEntityToNode(node.id,'npcs',globalNpcs.find(n=>n.name===e.target.value));e.target.value=""}}}>
                                                    <option value="">+ NPC 추가</option>
                                                    {globalNpcs.map((n,i)=><option key={i} value={n.name}>{n.name}</option>)}
                                                </select>
                                            </div>

                                            <div className="pt-2 border-t border-[#4A4A6A] mt-2">
                                                <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">등장 적</label>
                                                <div className="space-y-1 mb-2">
                                                    {(node.data.enemies||[]).map((e,i) => (
                                                        <div key={i} className="flex justify-between p-1 bg-[#0B0B19] border border-[#4A4A6A] text-xs text-[#FF007F]">
                                                            {e.name} <button onClick={()=>removeEntityFromNode(node.id,'enemies',i)}><Icon name="x" size={12}/></button>
                                                        </div>
                                                    ))}
                                                </div>
                                                <select className="w-full pixel-input p-1 text-xs" onChange={(e)=>{if(e.target.value){addEntityToNode(node.id,'enemies',globalEnemies.find(n=>n.name===e.target.value));e.target.value=""}}}>
                                                    <option value="">+ 적 추가</option>
                                                    {globalEnemies.map((n,i)=><option key={i} value={n.name}>{n.name}</option>)}
                                                </select>
                                            </div>
                                        </>
                                    )}

                                    <div className="mt-4 pt-4 border-t-2 border-[#4A4A6A]">
                                        <label className="text-[10px] text-[#6A6A8A] block mb-1 flex items-center gap-1 font-bold"><Icon name="brain-circuit" size={12}/> AI 제안 노트</label>
                                        <textarea className="w-full pixel-input p-2 text-xs h-20 resize-none text-[#FFFACD]"
                                                  value={node.data.ai_note || ''} readOnly></textarea>
                                    </div>

                                    <div className="mt-4 pt-4 border-t-2 border-[#4A4A6A]">
                                        <label className="text-[10px] text-[#6A6A8A] block mb-1 flex items-center gap-1 font-bold"><Icon name="image" size={12}/> AI 이미지 생성</label>
                                        
                                        {/* 이미지 생성 탭 */}
                                        <div className="space-y-3">
                                            <div>
                                                <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">이미지 종류</label>
                                                <select className="w-full pixel-input p-2 text-xs" id="imageTypeSelect">
                                                    <option value="npc">NPC 초상화</option>
                                                    <option value="enemy">적 이미지</option>
                                                    <option value="background">씬 배경</option>
                                                </select>
                                            </div>
                                            
                                            <div>
                                                <label className="text-[10px] text-[#6A6A8A] block mb-1 font-bold">설명</label>
                                                <input 
                                                    type="text" 
                                                    className="w-full pixel-input p-2 text-xs" 
                                                    id="imageDescriptionInput"
                                                    placeholder="생성할 이미지를 설명하세요"
                                                />
                                            </div>
                                            
                                            <button 
                                                onClick={() => {
                                                    const imageType = document.getElementById('imageTypeSelect').value;
                                                    const description = document.getElementById('imageDescriptionInput').value;
                                                    if (!description.trim()) {
                                                        showToast("이미지 설명을 입력하세요", "error");
                                                        return;
                                                    }
                                                    generateImage(imageType, description);
                                                }}
                                                disabled={imageGenState.isLoading}
                                                className="pixel-btn w-full py-2 text-xs text-[#00FFFF] border-[#00FFFF] disabled:opacity-50"
                                            >
                                                {imageGenState.isLoading ? (
                                                    <>
                                                        <div className="w-3 h-3 border border-[#00FFFF] border-t-transparent animate-spin mr-2"></div>
                                                        생성 중...
                                                    </>
                                                ) : (
                                                    <>
                                                        <Icon name="sparkles" size={12}/> 이미지 생성
                                                    </>
                                                )}
                                            </button>
                                            
                                            {/* 생성된 이미지 미리보기 */}
                                            {imageGenState.result && (
                                                <div className="mt-3 p-3 bg-[#0B0B19] border border-[#4A4A6A]">
                                                    <div className="text-[10px] text-[#6A6A8A] mb-2 font-bold">생성된 이미지</div>
                                                    <img 
                                                        src={imageGenState.result.image_url} 
                                                        alt="Generated" 
                                                        className="w-full h-32 object-cover border border-[#4A4A6A]"
                                                    />
                                                    <div className="text-[10px] text-[#6A6A8A] mt-2">
                                                        {imageGenState.result.description}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2 pt-4">
                                        <button onClick={() => runAiAudit(node.id)} className="pixel-btn py-2 text-xs col-span-2 text-[#6366f1] border-[#6366f1]"><Icon name="brain-circuit"/> 씬 검수</button>
                                        {!isStart && <button onClick={() => deleteNode(node.id)} className="pixel-btn py-2 text-xs col-span-2 text-[#FF007F] border-[#FF007F]"><Icon name="trash-2"/> 삭제</button>}
                                    </div>
                                </div>
                            );
                        })() : (
                            <div className="h-full flex flex-col items-center justify-center text-[#6A6A8A] gap-4">
                                <Icon name="mouse-pointer-2" size={48} className="opacity-50"/>
                                <p className="text-xs text-center font-bold">편집할 노드를<br/>선택하세요</p>
                            </div>
                        )}
                    </div>

                    {/* Modals */}
                    <Modal isOpen={modals.npcList} title="NPC 목록" onClose={() => setModals(m=>({...m, npcList:false}))}>
                        <div className="space-y-2">
                            {dbNpcList.map((npc, i) => (
                                <div key={i} className="flex justify-between items-center p-3 bg-[#0B0B19] border border-[#4A4A6A] hover:border-[#FFFACD] transition-colors">
                                    <div>
                                        <div className="font-bold text-white text-sm">{npc.name}</div>
                                        <div className="text-[10px] text-[#10b981]">{npc.isEnemy?'ENEMY':'NPC'}</div>
                                    </div>
                                    <button onClick={() => { (npc.isEnemy ? setGlobalEnemies : setGlobalNpcs)(prev => [...prev, npc]); showToast("추가됨", "success"); }}
                                            className="pixel-btn px-3 py-1 text-xs">추가</button>
                                </div>
                            ))}
                        </div>
                    </Modal>

                    <Modal isOpen={modals.scenarioList} title="시나리오 불러오기" onClose={() => setModals(m=>({...m, scenarioList:false}))}>
                         <div className="space-y-2">
                            {userScenarios.map(s => (
                                <div key={s.id} onClick={() => window.location.href=`/views/scenes/edit/${s.filename}` }
                                     className="p-4 bg-[#0B0B19] border border-[#4A4A6A] hover:border-[#00FFFF] cursor-pointer group transition-all">
                                    <div className="font-bold text-[#FFFACD] group-hover:text-white">{s.title}</div>
                                    <div className="text-xs text-[#6A6A8A] mt-1 truncate">{s.prologue}</div>
                                </div>
                            ))}
                         </div>
                    </Modal>

                    <Modal isOpen={modals.presetLoad} title="프리셋 불러오기" onClose={() => setModals(m=>({...m, presetLoad:false}))}>
                        <div className="space-y-2">
                            {presetList.map((p, i) => (
                                <div key={i} onClick={() => loadPreset(p)}
                                     className="p-4 bg-[#0B0B19] border border-[#4A4A6A] hover:border-[#FF007F] cursor-pointer group transition-all flex justify-between">
                                    <div>
                                        <div className="font-bold text-[#E0E0E0]">{p.name}</div>
                                        <div className="text-xs text-[#6A6A8A]">{p.description}</div>
                                    </div>
                                    <Icon name="download" className="text-[#6A6A8A] group-hover:text-white"/>
                                </div>
                            ))}
                        </div>
                    </Modal>

                    {/* Audit Result Modal */}
                    {auditState.isOpen && (
                        <div className="fixed inset-0 z-[150] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-fade-in p-4">
                            <div className="pixel-box w-full max-w-3xl bg-[#131320] border-2 border-[#4A4A6A] max-h-[80vh] flex flex-col">
                                <div className="p-4 border-b-2 border-[#4A4A6A] bg-[#1A0B2E] flex justify-between items-center">
                                    <h3 className="text-[#FFFACD] flex items-center gap-2 font-bold"><Icon name="brain-circuit"/> AI 검수 리포트</h3>
                                    <button onClick={() => setAuditState(p => ({...p, isOpen: false}))} className="text-[#6A6A8A] hover:text-white"><Icon name="x"/></button>
                                </div>
                                <div className="p-6 overflow-y-auto custom-scrollbar flex-1">
                                    {auditState.isLoading ? (
                                        <div className="text-center py-12 text-[#6A6A8A] font-bold animate-pulse">논리적 결함을 분석 중입니다...</div>
                                    ) : (
                                        <div className="space-y-4">
                                            {auditState.results?.issues.length === 0 ? (
                                                <div className="text-center py-8">
                                                    <div className="text-[#10b981] text-lg mb-2 font-bold">완벽합니다!</div>
                                                    <p className="text-sm text-[#E0E0E0]">발견된 서사적 오류가 없습니다.</p>
                                                </div>
                                            ) : (
                                                auditState.results?.issues.map((issue, idx) => (
                                                    <div key={idx} className="bg-[#0B0B19] border border-[#4A4A6A] p-4">
                                                        <div className="flex justify-between mb-2">
                                                            <span className="text-[10px] bg-[#4A4A6A] px-2 py-1 text-white">{issue.scene_id}</span>
                                                            <span className={`text-[10px] px-2 py-1 font-bold ${issue.severity==='error'?'text-[#FF007F] border border-[#FF007F]':'text-[#f59e0b] border border-[#f59e0b]'}`}>{issue.severity}</span>
                                                        </div>
                                                        <div className="grid md:grid-cols-2 gap-4 text-xs">
                                                            <div className="text-[#f59e0b] p-2 border border-[#f59e0b]/30 bg-[#f59e0b]/10">
                                                                <div className="font-bold mb-1">문제점 (Problem)</div>{issue.message}
                                                            </div>
                                                            <div className="text-[#10b981] p-2 border border-[#10b981]/30 bg-[#10b981]/10">
                                                                <div className="font-bold mb-1">제안 (Suggestion)</div>{issue.suggestion}
                                                            </div>
                                                        </div>
                                                        <button onClick={() => applySuggestion(issue)} className="pixel-btn w-full mt-3 py-2 text-xs flex justify-center gap-2"><Icon name="pen-tool" size={12}/> 수정 제안 반영</button>
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {modals.npcGen && (
                        <div className="fixed inset-0 z-[150] flex items-center justify-center bg-black/90 p-4">
                            <div className="bg-[#131320] w-full max-w-4xl h-[85vh] pixel-box flex flex-col">
                                <div className="p-2 border-b-2 border-[#4A4A6A] flex justify-end"><button onClick={() => setModals(m=>({...m, npcGen:false}))}><Icon name="x"/></button></div>
                                <iframe src="/builder/npc-generator" className="w-full h-full border-none" title="NPC Gen"></iframe>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ScenarioBuilder />);
    </script>
    {% endraw %}
</body>
</html>