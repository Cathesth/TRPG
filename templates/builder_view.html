<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRPG - Scenario Builder & Editor</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { background-color: #111; color: #fff; margin: 0; overflow: hidden; font-family: 'Pretendard', sans-serif; }
        .bg-dots-pattern { background-image: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px; }
        .no-select { user-select: none; -webkit-user-select: none; }
        ::-webkit-scrollbar { width: 6px; background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

        .connection-line { stroke: #6b7280; stroke-width: 3; fill: none; transition: stroke 0.2s; }
        .connection-line:hover { stroke: #f59e0b; stroke-width: 4; cursor: pointer; filter: drop-shadow(0 0 4px #f59e0b); }
        .connecting-line { stroke: #6366f1; stroke-width: 3; stroke-dasharray: 8,4; fill: none; animation: dash 0.5s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -12; } }

        .node-shadow { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5); }
        .animate-fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body class="bg-black text-white h-screen w-screen">

    <div id="root" class="w-full h-full"></div>

    {% raw %}
    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- [ìˆ˜ì • ì™„ë£Œ] ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸ ---
        // CDN í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ì‘ë™í•˜ë„ë¡ ìˆ˜ì •ë¨.
        // Reactê°€ ê´€ë¦¬í•˜ëŠ” span ë‚´ë¶€ë¥¼ ë¹„ìš°ê³ , Lucide APIë¥¼ ì‚¬ìš©í•´ SVGë¥¼ ì£¼ì…í•©ë‹ˆë‹¤.
        const Icon = ({ name, size = 18, className = "" }) => {
            const ref = useRef(null);

            useEffect(() => {
                if (!window.lucide || !ref.current) return;

                // 1. ê¸°ì¡´ ë‚´ìš© ì´ˆê¸°í™”
                ref.current.innerHTML = '';

                // 2. ì„ì‹œ íƒœê·¸ ìƒì„± (Lucideê°€ ì´ê±¸ ì°¾ì•„ì„œ SVGë¡œ êµì²´í•¨)
                const i = document.createElement('i');
                i.setAttribute('data-lucide', name);
                ref.current.appendChild(i);

                // 3. ë Œë”ë§ ì‹¤í–‰ (ì´ ìš”ì†Œ ë‚´ë¶€ë§Œ íƒ€ê²ŸíŒ…)
                window.lucide.createIcons({
                    root: ref.current,
                    nameAttr: 'data-lucide',
                    attrs: {
                        width: size,
                        height: size,
                        class: className
                    }
                });
            }, [name, size, className]);

            return <span ref={ref} style={{ display: 'inline-flex', alignItems: 'center', justifyContent: 'center' }}></span>;
        };

        // --- ê³µìš© ëª¨ë‹¬ ---
        const Modal = ({ isOpen, title, onClose, children, footer }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm animate-fade-in p-4">
                    <div className="bg-gray-900 border border-gray-700 rounded-xl shadow-2xl w-full max-w-2xl max-h-[85vh] flex flex-col">
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-800 rounded-t-xl">
                            <h3 className="font-bold text-white flex items-center gap-2">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white"><Icon name="x"/></button>
                        </div>
                        <div className="p-4 overflow-y-auto custom-scrollbar flex-1">{children}</div>
                        {footer && <div className="p-4 border-t border-gray-700 bg-gray-800 rounded-b-xl flex justify-end gap-2">{footer}</div>}
                    </div>
                </div>
            );
        };

        // --- ì»¨ë²„í„° ìœ í‹¸ë¦¬í‹° (Legacy Scenes -> React Flow Nodes) ---
        const convertScenesToNodes = (scenData) => {
            const nodes = [];
            const edges = [];
            let yOffset = 50;
            const xBase = 400;

            // 1. Start Node
            nodes.push({
                id: 'start', type: 'start', x: 50, y: 50,
                data: {
                    label: scenData.title || 'ì‹œë‚˜ë¦¬ì˜¤ ì„¤ì •',
                    prologue: scenData.prologue || '',
                    gm_notes: scenData.gm_notes || '',
                    background: scenData.background || ''
                }
            });

            // 2. Scenes
            (scenData.scenes || []).forEach((s, idx) => {
                const node = {
                    id: s.scene_id,
                    type: 'scene',
                    x: xBase,
                    y: yOffset + (idx * 150),
                    data: {
                        title: s.title || s.name || s.scene_id,
                        description: s.description || '',
                        background: s.background || '',
                        trigger: s.trigger || '',
                        npcs: s.npcs || [],
                        enemies: s.enemies || []
                    }
                };
                nodes.push(node);
            });

            // 3. Endings
            const endingYStart = yOffset + ((scenData.scenes || []).length * 150);
            (scenData.endings || []).forEach((e, idx) => {
                const node = {
                    id: e.ending_id,
                    type: 'ending',
                    x: xBase + 400,
                    y: endingYStart + (idx * 150),
                    data: {
                        title: e.title || 'ì—”ë”©',
                        description: e.description || '',
                        background: e.background || ''
                    }
                };
                nodes.push(node);
            });

            // 4. Connections
            (scenData.prologue_connects_to || []).forEach(targetId => {
                edges.push({ id: `e-start-${targetId}`, source: 'start', target: targetId });
            });

            (scenData.scenes || []).forEach(s => {
                (s.transitions || []).forEach((t, i) => {
                    if (t.target_scene_id) {
                        edges.push({
                            id: `e-${s.scene_id}-${t.target_scene_id}-${i}`,
                            source: s.scene_id,
                            target: t.target_scene_id
                        });
                    }
                });
            });

            return { nodes, edges };
        };

        // --- ë©”ì¸ ì»´í¬ë„ŒíŠ¸ ---
        function ScenarioBuilder() {
            // [State] ë°ì´í„°
            const [nodes, setNodes] = useState([
                { id: 'start', type: 'start', x: 50, y: 50, data: { label: 'ì‹œë‚˜ë¦¬ì˜¤ ì„¤ì •', prologue: '', gm_notes: '', background: '' } },
                { id: 'scene-1', type: 'scene', x: 400, y: 150, data: { title: 'ì²« ë²ˆì§¸ ì¥ë©´', description: '', background: '', trigger: '', npcs: [], enemies: [] } }
            ]);
            const [edges, setEdges] = useState([]);
            const [globalNpcs, setGlobalNpcs] = useState([]);
            const [globalEnemies, setGlobalEnemies] = useState([]);

            // [State] UI & ëª¨ë“œ
            const [isEditMode, setIsEditMode] = useState(false);
            const [scenarioId, setScenarioId] = useState(null);
            const [isDraft, setIsDraft] = useState(false);
            const [isGenerating, setIsGenerating] = useState(false);

            // [State] ìº”ë²„ìŠ¤ ì¡°ì‘
            const [pan, setPan] = useState({ x: 0, y: 0, zoom: 1 });
            const [isPanning, setIsPanning] = useState(false);
            const [dragNode, setDragNode] = useState(null);
            const [connectSource, setConnectSource] = useState(null);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [selectedNodeId, setSelectedNodeId] = useState(null);
            const canvasRef = useRef(null);

            // [State] ëª¨ë‹¬ ê´€ë¦¬
            const [modals, setModals] = useState({
                npcGen: false, npcList: false, presetLoad: false, scenarioList: false
            });
            const [toast, setToast] = useState({ show: false, msg: '', type: 'info' });

            // [State] ë°ì´í„° ëª©ë¡
            const [presetList, setPresetList] = useState([]);
            const [dbNpcList, setDbNpcList] = useState([]);
            const [userScenarios, setUserScenarios] = useState([]);
            const [selectedModel, setSelectedModel] = useState('openai/tngtech/deepseek-r1t2-chimera:free');

            // [History] Undo/Redo
            const [history, setHistory] = useState({ past: [], future: [] });

            // --- History Logic ---
            const pushHistory = useCallback(() => {
                setHistory(curr => ({
                    past: [...curr.past, { nodes: JSON.parse(JSON.stringify(nodes)), edges: JSON.parse(JSON.stringify(edges)) }],
                    future: []
                }));
            }, [nodes, edges]);

            const undo = () => {
                if (history.past.length === 0) return;
                const previous = history.past[history.past.length - 1];
                const newPast = history.past.slice(0, -1);
                setHistory({
                    past: newPast,
                    future: [{ nodes, edges }, ...history.future]
                });
                setNodes(previous.nodes);
                setEdges(previous.edges);
            };

            const redo = () => {
                if (history.future.length === 0) return;
                const next = history.future[0];
                const newFuture = history.future.slice(1);
                setHistory({
                    past: [...history.past, { nodes, edges }],
                    future: newFuture
                });
                setNodes(next.nodes);
                setEdges(next.edges);
            };

            // --- ì´ˆê¸°í™” ---
            useEffect(() => {
                const path = window.location.pathname;
                const match = path.match(/\/views\/scenes\/edit\/(\d+)/);
                if (match) {
                    const sid = match[1];
                    setScenarioId(sid);
                    setIsEditMode(true);
                    loadScenarioData(sid);
                }
            }, []);

            const loadScenarioData = async (sid) => {
                try {
                    let res = await fetch(`/api/draft/${sid}`);
                    let data = await res.json();

                    if (!data.success || !data.scenario) {
                        res = await fetch(`/api/scenario/${sid}/edit`);
                        data = await res.json();
                        if(data.data) data = { success: true, scenario: data.data.scenario };
                    } else {
                        setIsDraft(data.is_draft);
                    }

                    if (data.scenario) {
                        const scen = data.scenario;
                        let loadedNodes = scen.nodes;
                        let loadedEdges = scen.edges;

                        if ((!loadedNodes || loadedNodes.length === 0) && scen.scenes) {
                            const converted = convertScenesToNodes(scen);
                            loadedNodes = converted.nodes;
                            loadedEdges = converted.edges;
                        }

                        setNodes(loadedNodes || []);
                        setEdges(loadedEdges || []);
                        setGlobalNpcs(scen.npcs?.filter(n => !n.isEnemy && !n.is_enemy) || []);
                        setGlobalEnemies(scen.npcs?.filter(n => n.isEnemy || n.is_enemy) || []);

                        showToast("ì‹œë‚˜ë¦¬ì˜¤ ë¡œë“œ ì™„ë£Œ", "success");
                    }
                } catch (e) {
                    showToast("ë¡œë“œ ì‹¤íŒ¨: " + e.message, "error");
                }
            };

            // --- ì•¡ì…˜ í•¸ë“¤ëŸ¬ ---
            const addNode = (type) => {
                pushHistory();
                const id = `${type}-${Date.now()}`;
                const newData = type === 'scene'
                    ? { title: 'ìƒˆ ì¥ë©´', description: '', background: '', trigger: '' }
                    : { title: 'ìƒˆ ì—”ë”©', description: '', background: '' };
                const newNode = { id, type, x: -pan.x/pan.zoom + 200, y: -pan.y/pan.zoom + 200, data: newData };
                setNodes(prev => [...prev, newNode]);
            };

            const deleteNode = (id) => {
                if (id === 'start') return showToast("ì‹œì‘ ë…¸ë“œëŠ” ì‚­ì œ ë¶ˆê°€", "error");
                const connected = edges.filter(e => e.source === id || e.target === id);
                if (connected.length > 0) {
                    if (!confirm(`ì—°ê²°ëœ ${connected.length}ê°œì˜ ì„ ì´ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
                }
                pushHistory();
                setNodes(prev => prev.filter(n => n.id !== id));
                setEdges(prev => prev.filter(e => e.source !== id && e.target !== id));
                setSelectedNodeId(null);
            };

            const updateNodeData = (id, key, value) => {
                setNodes(prev => prev.map(n => n.id === id ? { ...n, data: { ...n.data, [key]: value } } : n));
            };

            // --- ì €ì¥ ë° ìƒì„± ---
            const saveDraft = async () => {
                if (!scenarioId) return;
                try {
                    const payload = { nodes, edges, npcs: [...globalNpcs, ...globalEnemies] };
                    const res = await fetch(`/api/draft/${scenarioId}/save`, {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(payload)
                    });
                    const json = await res.json();
                    if (json.success) {
                        setIsDraft(true);
                        showToast("Draft ì €ì¥ ì™„ë£Œ", "success");
                    } else throw new Error(json.error);
                } catch (e) { showToast(e.message, "error"); }
            };

            const publishScenario = async () => {
                if (!confirm("ë°˜ì˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
                try {
                    const res = await fetch(`/api/draft/${scenarioId}/publish`, { method: 'POST' });
                    const json = await res.json();
                    if (json.success) {
                        setIsDraft(false);
                        showToast("ë°˜ì˜ ì™„ë£Œ!", "success");
                    } else throw new Error(json.error);
                } catch (e) { showToast(e.message, "error"); }
            };

            const generateNewScenario = async () => {
                if (nodes.length < 2) return showToast("ìµœì†Œ 2ê°œì˜ ë…¸ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.", "error");

                setIsGenerating(true); // ë¡œë”© ì‹œì‘

                try {
                    const payload = {
                        nodes, edges, npcs: [...globalNpcs, ...globalEnemies], model: selectedModel,
                        title: nodes[0].data.label
                    };

                    const res = await fetch('/api/init_game', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(payload)
                    });
                    const json = await res.json();
                    if (json.filename) {
                        window.location.href = `/views/scenes/edit/${json.filename}`;
                    } else throw new Error(json.error);
                } catch (e) {
                    showToast(e.message, "error");
                    setIsGenerating(false); // ì—ëŸ¬ ì‹œ ë¡œë”© ì¢…ë£Œ
                }
            };

            const runAiAudit = async (node) => {
                if (!node) return;
                showToast(`AIê°€ "${node.data.title}" ê²€ìˆ˜ ì¤‘...`, "info");
                try {
                    const res = await fetch('/api/audit/scene', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ scenario: { nodes, edges }, scene_id: node.id })
                    });
                    const json = await res.json();

                    if (json.success && json.result) {
                        const r = json.result;
                        // ê°œì—°ì„±(coherence) ì´ìŠˆì™€ íŠ¸ë¦¬ê±°(trigger) ì´ìŠˆë¥¼ í•©ì¹¨
                        const issues = [
                            ...(r.coherence?.issues || []),
                            ...(r.trigger?.issues || [])
                        ];

                        if (issues.length === 0) {
                            alert(`[AI ê²€ìˆ˜ ê²°ê³¼: PASS]\n\nì™„ë²½í•©ë‹ˆë‹¤! ì„œì‚¬ì  ì˜¤ë¥˜ë‚˜ ì—°ê²° ë¬¸ì œê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                        } else {
                            // ì´ìŠˆ ë‚´ìš©ì„ ë³´ê¸° ì¢‹ê²Œ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
                            const report = issues.map((issue, idx) =>
                                `${idx+1}. [${issue.issue_type || 'ì•Œë¦¼'}] ${issue.message}\n   ğŸ’¡ ì œì•ˆ: ${issue.suggestion}`
                            ).join('\n\n');

                            alert(`[AI ê²€ìˆ˜ ê²°ê³¼: ${issues.length}ê±´ì˜ ê°œì„ ì  ë°œê²¬]\n\n${report}`);
                        }
                    } else {
                        throw new Error(json.error || "ê²€ìˆ˜ ê²°ê³¼ ë°ì´í„°ë¥¼ ë¶„ì„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    }
                } catch (e) {
                    console.error(e);
                    showToast("AI ê²€ìˆ˜ ì‹¤íŒ¨: " + e.message, "error");
                }
            };

            // --- ìº”ë²„ìŠ¤ í•¸ë“¤ëŸ¬ ---
            const handleMouseDown = (e) => {
                if (e.target.closest('.node-ui')) return;
                if (e.button === 0 || e.button === 1) setIsPanning(true);
            };
            const handleMouseMove = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left - pan.x) / pan.zoom;
                const y = (e.clientY - rect.top - pan.y) / pan.zoom;
                setMousePos({ x, y });

                if (isPanning) {
                    setPan(p => ({ ...p, x: p.x + e.movementX, y: p.y + e.movementY }));
                } else if (dragNode) {
                    setNodes(prev => prev.map(n => n.id === dragNode ? { ...n, x, y } : n));
                }
            };
            const handleMouseUp = () => {
                if (dragNode) pushHistory();
                setIsPanning(false); setDragNode(null); setConnectSource(null);
            };
            const handleNodeDragStart = (e, id) => {
                e.stopPropagation();
                if (connectSource && connectSource !== id) {
                    if (!edges.some(eg => eg.source === connectSource && eg.target === id)) {
                        pushHistory();
                        setEdges(prev => [...prev, { id: `e-${Date.now()}`, source: connectSource, target: id }]);
                    }
                    setConnectSource(null);
                } else {
                    setDragNode(id); setSelectedNodeId(id);
                }
            };

            const showToast = (msg, type) => {
                setToast({ show: true, msg, type });
                setTimeout(() => setToast({ show: false, msg: '', type: 'info' }), 3000);
            };

            return (
                <div className="flex h-screen overflow-hidden text-sm font-sans" onMouseUp={handleMouseUp} onMouseMove={handleMouseMove}>

                    {/* ë¡œë”© ì˜¤ë²„ë ˆì´ */}
                    {isGenerating && (
                        <div className="fixed inset-0 z-[200] bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center text-white animate-fade-in">
                            <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
                            <div className="text-xl font-bold">AIê°€ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤...</div>
                            <div className="text-sm text-gray-400 mt-2">ìµœëŒ€ 1ë¶„ ì •ë„ ì†Œìš”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
                        </div>
                    )}

                    {toast.show && (
                        <div className={`fixed top-5 left-1/2 -translate-x-1/2 z-[100] px-4 py-2 rounded shadow-lg font-bold animate-fade-in ${toast.type==='error'?'bg-red-600':toast.type==='success'?'bg-green-600':'bg-blue-600'}`}>
                            {toast.msg}
                        </div>
                    )}

                    {/* ì¢Œì¸¡ íˆ´ë°” */}
                    <div className="w-64 bg-gray-900 border-r border-gray-800 flex flex-col z-20 shadow-2xl">
                        <div className="p-4 border-b border-gray-800 flex items-center justify-between">
                            <span className="font-bold text-lg bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">Builder</span>
                            <a href="/" className="text-gray-500 hover:text-white"><Icon name="home"/></a>
                        </div>

                        <div className="p-4 space-y-3 overflow-y-auto flex-1 custom-scrollbar">
                            <div className="text-xs font-bold text-gray-500 uppercase mb-1">Create</div>
                            <button onClick={() => addNode('scene')} className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-indigo-300 flex items-center justify-center gap-2 transition-colors">
                                <Icon name="plus-square"/> ì”¬ ì¶”ê°€
                            </button>
                            <button onClick={() => addNode('ending')} className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-red-300 flex items-center justify-center gap-2 transition-colors">
                                <Icon name="flag"/> ì—”ë”© ì¶”ê°€
                            </button>

                            <div className="h-px bg-gray-800 my-2"></div>

                            <div className="text-xs font-bold text-gray-500 uppercase mb-1">Assets</div>
                            <button onClick={() => setModals(m => ({ ...m, npcGen: true }))} className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-green-300 flex items-center justify-center gap-2">
                                <Icon name="user-plus"/> NPC ìƒì„±
                            </button>
                            <button onClick={async () => {
                                try { const res = await fetch('/api/npc/list'); const data = await res.json(); setDbNpcList(data); setModals(m=>({...m, npcList:true})); } catch(e){ showToast("ë¡œë“œ ì‹¤íŒ¨","error"); }
                            }} className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-teal-300 flex items-center justify-center gap-2">
                                <Icon name="users"/> NPC ë¶ˆëŸ¬ì˜¤ê¸°
                            </button>

                            <div className="h-px bg-gray-800 my-2"></div>

                            <div className="text-xs font-bold text-gray-500 uppercase mb-1">Tools</div>
                            <div className="flex gap-2">
                                <button onClick={undo} className="flex-1 py-2 bg-gray-800 hover:bg-gray-700 rounded text-gray-400" title="Undo"><Icon name="undo-2"/></button>
                                <button onClick={redo} className="flex-1 py-2 bg-gray-800 hover:bg-gray-700 rounded text-gray-400" title="Redo"><Icon name="redo-2"/></button>
                            </div>
                            <button onClick={async () => {
                                try { const res = await fetch('/api/presets'); const data = await res.json(); setPresetList(data); setModals(m=>({...m, presetLoad:true})); } catch(e){}
                            }} className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-blue-300 flex items-center justify-center gap-2 mt-2">
                                <Icon name="folder-open"/> í”„ë¦¬ì…‹ ë¡œë“œ
                            </button>
                            <button onClick={async () => {
                                try { const res = await fetch('/api/scenarios/data?filter=my'); const data = await res.json(); setUserScenarios(data); setModals(m=>({...m, scenarioList:true})); } catch(e){}
                            }} className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-purple-300 flex items-center justify-center gap-2 mt-2">
                                <Icon name="file-edit"/> ì‹œë‚˜ë¦¬ì˜¤ ë¡œë“œ
                            </button>
                        </div>

                        <div className="p-4 border-t border-gray-800 bg-gray-900 z-20">
                            {!isEditMode && (
                                <div className="mb-3">
                                    <label className="text-xs text-gray-500 block mb-1">AI Model</label>
                                    <select value={selectedModel} onChange={e => setSelectedModel(e.target.value)}
                                            className="w-full bg-gray-950 border border-gray-700 rounded px-2 py-1 text-xs text-gray-300">
                                        <option value="openai/tngtech/deepseek-r1t2-chimera:free">DeepSeek R1 (Free)</option>
                                        <option value="openai/google/gemini-2.5-flash">Gemini 2.5 Flash</option>
                                        <option value="openai/anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet</option>
                                        <option value="openai/openai/gpt-4o">GPT-4o</option>
                                    </select>
                                </div>
                            )}

                            {isEditMode ? (
                                <div className="space-y-2">
                                    <button onClick={saveDraft} className="w-full py-2 bg-blue-900/50 border border-blue-700 hover:bg-blue-800 text-blue-200 rounded font-bold flex items-center justify-center gap-2">
                                        <Icon name="save"/> Draft ì €ì¥
                                    </button>
                                    <button onClick={publishScenario} className="w-full py-2 bg-green-700 hover:bg-green-600 text-white rounded font-bold flex items-center justify-center gap-2 shadow-lg">
                                        <Icon name="upload"/> ìµœì¢… ë°˜ì˜
                                    </button>
                                </div>
                            ) : (
                                <button onClick={generateNewScenario} className="w-full py-3 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white font-bold rounded shadow-lg flex items-center justify-center gap-2">
                                    <Icon name="play"/> ì‹œë‚˜ë¦¬ì˜¤ ìƒì„±
                                </button>
                            )}
                        </div>
                    </div>

                    {/* ìº”ë²„ìŠ¤ */}
                    <div ref={canvasRef} className="flex-1 relative bg-[#0a0a0a] bg-dots-pattern cursor-crosshair overflow-hidden"
                         onMouseDown={handleMouseDown}
                         onWheel={(e) => setPan(p => ({ ...p, zoom: Math.min(Math.max(0.2, p.zoom - e.deltaY * 0.001), 3) }))}>

                        <div style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${pan.zoom})`, transformOrigin: '0 0', width: '100%', height: '100%' }}>
                            <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible">
                                {edges.map(e => {
                                    const s = nodes.find(n => n.id === e.source), t = nodes.find(n => n.id === e.target);
                                    if(!s || !t) return null;
                                    return <line key={e.id} x1={s.x+100} y1={s.y+40} x2={t.x+100} y2={t.y+40} className="connection-line" stroke="#666" />;
                                })}
                                {connectSource && (() => {
                                    const s = nodes.find(n => n.id === connectSource);
                                    return <line x1={s.x+100} y1={s.y+40} x2={mousePos.x} y2={mousePos.y} className="connecting-line" />;
                                })()}
                            </svg>

                            {nodes.map(node => (
                                <div key={node.id} style={{ left: node.x, top: node.y }}
                                     onMouseDown={(e) => handleNodeDragStart(e, node.id)}
                                     className={`node-ui absolute w-[200px] bg-gray-900 border-2 rounded-lg node-shadow group transition-colors
                                        ${selectedNodeId === node.id ? 'border-white z-20 ring-2 ring-blue-500' :
                                          node.type==='start'?'border-blue-600':node.type==='ending'?'border-red-600':'border-indigo-600'}`}>

                                    <div className={`p-2 text-xs font-bold flex justify-between items-center cursor-grab active:cursor-grabbing
                                        ${node.type==='start'?'bg-blue-900/50 text-blue-200':node.type==='ending'?'bg-red-900/50 text-red-200':'bg-indigo-900/50 text-indigo-200'}`}>
                                        <span className="flex items-center gap-1">
                                            {node.type==='start' && <Icon name="settings" size={12}/>}
                                            {node.type==='scene' && <Icon name="clapperboard" size={12}/>}
                                            {node.type==='ending' && <Icon name="flag" size={12}/>}
                                            {node.type.toUpperCase()}
                                        </span>
                                        <button onMouseDown={(e) => {e.stopPropagation(); setConnectSource(node.id)}} className="p-1 hover:bg-white/20 rounded"><Icon name="link" size={12}/></button>
                                    </div>
                                    <div className="p-3 text-xs text-gray-300 min-h-[60px]">
                                        <div className="font-bold mb-1 truncate text-white">{node.data.title || node.data.label || 'ì œëª© ì—†ìŒ'}</div>
                                        <div className="text-gray-500 line-clamp-2">{node.data.description || node.data.prologue || 'ë‚´ìš© ì—†ìŒ'}</div>
                                    </div>
                                </div>
                            ))}
                        </div>

                        <div className="absolute top-4 right-4 bg-gray-900 border border-gray-700 rounded-lg p-2 flex flex-col gap-2 shadow-lg z-30">
                             <button onClick={() => setPan(p=>({...p, zoom: p.zoom+0.1}))} className="hover:text-blue-400"><Icon name="plus"/></button>
                             <button onClick={() => setPan({x:0, y:0, zoom:1})} className="text-xs font-mono">{Math.round(pan.zoom*100)}%</button>
                             <button onClick={() => setPan(p=>({...p, zoom: p.zoom-0.1}))} className="hover:text-blue-400"><Icon name="minus"/></button>
                        </div>

                        {isEditMode && (
                            <div className="absolute top-4 left-4 bg-black/60 backdrop-blur border border-gray-700 rounded-full px-4 py-1.5 flex items-center gap-2 z-30">
                                <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                                <span className="font-bold text-gray-200">{scenarioId}</span>
                                {isDraft && <span className="text-xs bg-blue-600/30 text-blue-300 px-2 rounded border border-blue-500/30">Draft</span>}
                            </div>
                        )}
                    </div>

                    {/* ì†ì„± íŒ¨ë„ */}
                    <div className="w-80 bg-gray-900 border-l border-gray-800 p-4 overflow-y-auto custom-scrollbar z-20 shadow-xl">
                        {selectedNodeId ? (() => {
                            const node = nodes.find(n => n.id === selectedNodeId);
                            if(!node) return null;
                            const isStart = node.type === 'start';

                            return (
                                <div className="space-y-4 animate-fade-in">
                                    <h3 className="font-bold border-b border-gray-700 pb-2 flex items-center gap-2">
                                        <Icon name="sliders"/> ì†ì„± í¸ì§‘
                                        <span className="text-xs bg-gray-800 px-2 py-0.5 rounded text-gray-400 ml-auto">{node.type}</span>
                                    </h3>

                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">ì œëª© <span className="text-red-500">*</span></label>
                                        <input className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm focus:border-blue-500 focus:outline-none"
                                               value={node.data.title || node.data.label || ''}
                                               onChange={e => updateNodeData(node.id, isStart?'label':'title', e.target.value)} />
                                    </div>

                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">{isStart ? 'í”„ë¡¤ë¡œê·¸' : 'ë‚´ìš©/ë¬˜ì‚¬'} <span className="text-red-500">*</span></label>
                                        <textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm h-32 resize-none focus:border-blue-500 focus:outline-none"
                                                  value={node.data.description || node.data.prologue || ''}
                                                  onChange={e => updateNodeData(node.id, isStart?'prologue':'description', e.target.value)}></textarea>
                                    </div>

                                    {node.type === 'scene' && (
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">ì§„ì… íŠ¸ë¦¬ê±°</label>
                                            <input className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm focus:border-blue-500 focus:outline-none"
                                                   value={node.data.trigger || ''}
                                                   placeholder="ì˜ˆ: ë¬¸ì„ ì—°ë‹¤, ì ì„ ì“°ëŸ¬ëœ¨ë¦°ë‹¤"
                                                   onChange={e => updateNodeData(node.id, 'trigger', e.target.value)} />
                                        </div>
                                    )}

                                    <div className="pt-4 border-t border-gray-800 grid grid-cols-2 gap-2">
                                        <button onClick={() => runAiAudit(node)} className="col-span-2 py-2 bg-violet-900/30 text-violet-300 border border-violet-700/50 rounded hover:bg-violet-800/30 flex items-center justify-center gap-2">
                                            <Icon name="brain-circuit"/> AI ê°œì—°ì„± ê²€ìˆ˜
                                        </button>

                                        {!isStart && (
                                            <button onClick={() => deleteNode(node.id)} className="col-span-2 py-2 bg-red-900/30 text-red-300 border border-red-700/50 rounded hover:bg-red-800/30 flex items-center justify-center gap-2 mt-2">
                                                <Icon name="trash-2"/> ì‚­ì œ
                                            </button>
                                        )}
                                    </div>
                                </div>
                            );
                        })() : (
                            <div className="h-full flex flex-col items-center justify-center text-gray-600 gap-2">
                                <Icon name="mouse-pointer-2" size={32} className="opacity-50"/>
                                <p>í¸ì§‘í•  ë…¸ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
                            </div>
                        )}
                    </div>

                    <Modal isOpen={modals.npcList} title="NPC ëª©ë¡" onClose={() => setModals(m=>({...m, npcList:false}))}>
                        <div className="space-y-2">
                            {dbNpcList.map((npc, i) => (
                                <div key={i} className="flex justify-between items-center p-3 bg-gray-800 rounded border border-gray-700">
                                    <div>
                                        <span className="font-bold text-white">{npc.name}</span>
                                        <span className={`text-xs ml-2 px-1.5 py-0.5 rounded ${npc.isEnemy?'bg-red-900 text-red-300':'bg-green-900 text-green-300'}`}>{npc.isEnemy?'Enemy':'NPC'}</span>
                                        <div className="text-xs text-gray-400">{npc.role || npc.description}</div>
                                    </div>
                                    <button onClick={() => {
                                        const list = npc.isEnemy ? setGlobalEnemies : setGlobalNpcs;
                                        list(prev => [...prev, npc]);
                                        showToast(`${npc.name} ì¶”ê°€ë¨`, "success");
                                    }} className="bg-gray-700 hover:bg-blue-600 px-3 py-1 rounded text-xs transition-colors">ì¶”ê°€</button>
                                </div>
                            ))}
                        </div>
                    </Modal>

                    <Modal isOpen={modals.scenarioList} title="ë‚´ ì‹œë‚˜ë¦¬ì˜¤" onClose={() => setModals(m=>({...m, scenarioList:false}))}>
                         <div className="space-y-2">
                            {userScenarios.map(s => (
                                <div key={s.id} onClick={() => window.location.href=`/views/scenes/edit/${s.filename}` }
                                     className="p-3 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded cursor-pointer group transition-colors">
                                    <div className="font-bold text-white group-hover:text-blue-400">{s.title}</div>
                                    <div className="text-xs text-gray-400 mt-1 line-clamp-2">{s.prologue}</div>
                                </div>
                            ))}
                         </div>
                    </Modal>

                    {modals.npcGen && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur p-4">
                            <div className="bg-gray-900 w-full max-w-2xl h-[80vh] rounded-xl border border-gray-700 flex flex-col relative overflow-hidden">
                                <button onClick={() => setModals(m=>({...m, npcGen:false}))} className="absolute top-2 right-2 p-2 bg-black/50 rounded-full hover:bg-red-600 z-10"><Icon name="x"/></button>
                                <iframe src="/builder/npc-generator" className="w-full h-full" title="NPC Gen"></iframe>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ScenarioBuilder />);
    </script>
    {% endraw %}

</body>
</html>