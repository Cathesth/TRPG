<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Builder</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

    <style>
        body { background-color: #111; color: #fff; margin: 0; overflow: hidden; font-family: sans-serif; }
        .bg-dots-pattern { background-image: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px; }
        .no-select { user-select: none; -webkit-user-select: none; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        .progress-shine { position: absolute; top: 0; left: 0; bottom: 0; right: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transform: translateX(-100%); animation: shine 2s infinite; }
        @keyframes shine { 100% { transform: translateX(100%); } }

        .connection-line { stroke: #6b7280; stroke-width: 3; fill: none; filter: drop-shadow(0 0 4px rgba(107, 114, 128, 0.5)); }
        .connection-line:hover { stroke: #9ca3af; stroke-width: 4; }
        .connecting-line { stroke: #6366f1; stroke-width: 3; stroke-dasharray: 8,4; fill: none; filter: drop-shadow(0 0 6px rgba(99, 102, 241, 0.6)); animation: dash 0.5s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -12; } }

        #global-error { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(50, 0, 0, 0.9); color: #ffcccc; z-index: 9999; padding: 20px; overflow: auto; white-space: pre-wrap; font-family: monospace; }
        .version-badge { position: fixed; bottom: 16px; right: 16px; font-size: 10px; color: #9ca3af; font-family: 'Courier New', monospace; z-index: 1000; pointer-events: none; user-select: none; }
    </style>
</head>
<body class="bg-black text-white h-screen w-screen">

    <div id="global-error"></div>
    <div id="root" class="w-full h-full"></div>

    {% raw %}
    <script type="text/babel">
        try {
            const { useState, useRef, useEffect } = React;

            const getIconPath = (name) => {
                const icons = {
                    'settings': 'M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z',
                    'users': 'M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2 M9 7a4 4 0 1 0 0-8 4 4 0 0 0 0 8 M22 21v-2a4 4 0 0 0-3-3.87 M16 3.13a4 4 0 0 1 0 7.75',
                    'play': 'polygon|5 3 19 12 5 21 5 3',
                    'link': 'M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71 M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71',
                    'x': 'M18 6 6 18 M6 6l12 12',
                    'log-out': 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4 M16 17l5-5-5-5 M21 12H9',
                    'loader-2': 'M21 12a9 9 0 1 1-6.219-8.56',
                    'check-circle': 'M22 11.08V12a10 10 0 1 1-5.93-9.14 M22 4L12 14.01l-3-3',
                    'alert-triangle': 'M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z M12 9v4 M12 17h.01',
                    'undo': 'M3 7v6h6 M21 17a9 9 0 0 0-9-9 9 9 0 0 0-9 9',
                    'redo': 'M21 7v6h-6 M3 17a9 9 0 0 1 9-9 9 9 0 0 1 9 9',
                    'swords': 'M14.5 17.5L3 6V3h3l11.5 11.5 M13 19l6-6 M16 16l4 4 M19 21l2-2'
                };
                return icons[name] || 'M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20z';
            };
            const Icon = ({ name, size = 20, className = "" }) => {
                const pathData = getIconPath(name);
                return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{pathData.startsWith('polygon|') ? <polygon points={pathData.split('|')[1]} /> : <path d={pathData} />}</svg>;
            };

            const Modal = ({ isOpen, title, children, onClose, type = 'info' }) => {
                if (!isOpen) return null;
                const colors = type === 'error' ? 'red' : type === 'success' ? 'green' : 'gray';
                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-fade-in">
                        <div className={`bg-gray-900 border border-${colors}-500/50 w-full max-w-lg rounded-xl shadow-2xl overflow-hidden`}>
                            <div className="p-4 border-b border-white/10 flex justify-between items-center bg-white/5">
                                <h3 className={`text-lg font-bold text-${colors === 'gray' ? 'white' : colors + '-400'} flex items-center gap-2`}>{type === 'success' && <Icon name="check-circle" />}{type === 'error' && <Icon name="alert-triangle" />}{title}</h3>
                                {onClose && <button onClick={onClose}><Icon name="x" size={20} className="text-gray-500 hover:text-white" /></button>}
                            </div>
                            <div className="p-6 text-gray-300 text-sm leading-relaxed">{children}</div>
                        </div>
                    </div>
                );
            };

            const LoadingOverlay = ({ isOpen, progress, buildStatus }) => {
                if (!isOpen) return null;
                const isError = buildStatus.status === 'error';
                return (
                    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/90 backdrop-blur-md p-4 animate-fade-in cursor-wait">
                        <div className="w-full max-w-xl text-center p-8 rounded-2xl bg-gray-900/50 border border-white/10 shadow-2xl relative overflow-hidden">
                            <div className={`mb-6 inline-block p-4 rounded-full ${isError ? 'bg-red-500/10 border-red-500/20' : 'bg-blue-500/10 border-blue-500/20'} border`}>
                                <Icon name={isError ? 'alert-triangle' : 'loader-2'} size={48} className={`${isError ? 'text-red-400' : 'animate-spin text-blue-400'}`} />
                            </div>
                            <h3 className="text-2xl font-bold text-white mb-2">{isError ? '생성 오류' : '시나리오 생성 중...'}</h3>
                            <p className="text-sm text-gray-400 mb-6">{buildStatus.detail}</p>
                            <div className="w-full bg-gray-800 rounded-full h-4 mb-3 overflow-hidden border border-white/5 relative">
                                <div className={`h-full transition-all duration-500 ease-out relative ${isError ? 'bg-red-600' : 'bg-gradient-to-r from-blue-600 via-indigo-500 to-purple-500'}`} style={{ width: `${progress}%` }}>{!isError && <div className="progress-shine"></div>}</div>
                            </div>
                        </div>
                    </div>
                );
            };

            // iframe 모달 (NPC 생성기)
            const NpcGeneratorModal = ({ isOpen, onClose, scenarioInfo }) => {
                const iframeRef = useRef(null);

                useEffect(() => {
                    const handleMessage = (event) => {
                         // iframe이 준비되면 시나리오 정보 전송
                        if (event.data.type === 'GENERATOR_READY' && iframeRef.current) {
                            iframeRef.current.contentWindow.postMessage({
                                type: 'SCENARIO_INFO',
                                payload: scenarioInfo
                            }, '*');
                        }
                    };
                    window.addEventListener('message', handleMessage);
                    return () => window.removeEventListener('message', handleMessage);
                }, [isOpen, scenarioInfo]);

                if (!isOpen) return null;

                return (
                    <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-md p-4">
                        <div className="bg-gray-900 w-full max-w-2xl h-[80vh] rounded-xl border border-gray-700 shadow-2xl flex flex-col overflow-hidden relative">
                             <div className="p-3 border-b border-gray-700 flex justify-between items-center bg-gray-800">
                                <h3 className="font-bold text-white flex items-center gap-2"><Icon name="users" /> NPC/Enemy 생성</h3>
                                <button onClick={onClose} className="text-gray-400 hover:text-white"><Icon name="x" /></button>
                            </div>
                            <iframe
                                ref={iframeRef}
                                src="/builder/npc-generator"
                                className="w-full h-full bg-gray-900"
                                title="NPC Generator"
                            />
                        </div>
                    </div>
                );
            };

            function ScenarioBuilder() {
                // 노드 기본값 설정 (필수 항목 포함)
                const [nodes, setNodes] = useState([
                    { id: 'start', type: 'start', x: 50, y: 50, data: { label: '시나리오 설정', prologue: '', gm_notes: '', background: '' } },
                    { id: 'scene-1', type: 'scene', x: 400, y: 150, data: { title: '첫 번째 장면', description: '', background: '', trigger: '', npcs: [], enemies: [], rule: '', scene_type: 'normal' } },
                ]);
                const [connections, setConnections] = useState([]);
                const [selectedNodeId, setSelectedNodeId] = useState(null);
                const [globalNpcs, setGlobalNpcs] = useState([]);
                const [globalEnemies, setGlobalEnemies] = useState([]);

                const [isNpcGeneratorOpen, setIsNpcGeneratorOpen] = useState(false);
                const [toast, setToast] = useState({ show: false, message: '', type: 'info' });

                // ... (History, Zoom, Pan state 등 기존 코드 유지)
                const [history, setHistory] = useState([]);
                const [historyIndex, setHistoryIndex] = useState(-1);
                const [zoom, setZoom] = useState(1);
                const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
                const [isPanning, setIsPanning] = useState(false);
                const [panStart, setPanStart] = useState({ x: 0, y: 0 });
                const [connectingSourceId, setConnectingSourceId] = useState(null);
                const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
                const [draggingNodeId, setDraggingNodeId] = useState(null);
                const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
                const canvasRef = useRef(null);

                const [buildStatus, setBuildStatus] = useState({});
                const [isLoading, setIsLoading] = useState(false);
                const [progress, setProgress] = useState(0);
                const [resultModal, setResultModal] = useState({ open: false });

                // Validation Logic
                const validateNode = (node) => {
                    const d = node.data;
                    if (node.type === 'start') {
                        return d.label && d.prologue && d.gm_notes && d.background;
                    } else if (node.type === 'scene') {
                        return d.title && d.background && d.trigger;
                    } else if (node.type === 'ending') {
                        return d.background && d.description; // description을 엔딩 문구로 사용
                    }
                    return true;
                };

                const showToast = (message, type = 'error') => {
                    setToast({ show: true, message, type });
                    setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 3000);
                };

                const handleMouseDownNode = (e, id) => {
                    e.stopPropagation();
                    if (connectingSourceId) {
                        // 연결 시도
                        if (connectingSourceId !== id) {
                            const sourceNode = nodes.find(n => n.id === connectingSourceId);
                            if (!validateNode(sourceNode)) {
                                showToast("필수 사항을 모두 입력해야 연결할 수 있습니다!", "error");
                                setConnectingSourceId(null);
                                return;
                            }
                            if (!connections.some(c => c.source === connectingSourceId && c.target === id)) {
                                setConnections(p => [...p, { id: `c-${Date.now()}`, source: connectingSourceId, target: id }]);
                            }
                        }
                        setConnectingSourceId(null);
                        return;
                    }
                    const node = nodes.find(n => n.id === id);
                    if (node) {
                        const rect = canvasRef.current.getBoundingClientRect();
                        setDragOffset({ x: (e.clientX - rect.left - panOffset.x)/zoom - node.x, y: (e.clientY - rect.top - panOffset.y)/zoom - node.y });
                        setSelectedNodeId(id);
                        setDraggingNodeId(id);
                    }
                };

                // ... (기본 이벤트 핸들러들: handleCanvasMouseMove, handleCanvasMouseUp, handleWheel 등 유지)
                const handleCanvasMouseMove = (e) => {
                    if(!canvasRef.current) return;
                    const rect = canvasRef.current.getBoundingClientRect();
                    const x = (e.clientX - rect.left - panOffset.x) / zoom;
                    const y = (e.clientY - rect.top - panOffset.y) / zoom;
                    setMousePos({ x, y });
                    if (isPanning) {
                         setPanOffset({ x: e.clientX - panStart.x, y: e.clientY - panStart.y });
                    } else if (draggingNodeId) {
                         setNodes(p => p.map(n => n.id === draggingNodeId ? { ...n, x: x - dragOffset.x, y: y - dragOffset.y } : n));
                    }
                };

                const handleCanvasMouseUp = () => {
                    setDraggingNodeId(null);
                    setIsPanning(false);
                };

                const handleBackgroundClick = (e) => {
                    if (e.target === canvasRef.current || e.target.id === 'svg-layer') {
                        setSelectedNodeId(null);
                        setConnectingSourceId(null);
                    }
                };

                useEffect(() => {
                    const handleMessage = (event) => {
                        if (event.data.type === 'ADD_NPC') {
                            const entity = event.data.payload;
                            if (entity.isEnemy) {
                                setGlobalEnemies(prev => [...prev, entity]);
                                showToast(`적 '${entity.name}' 추가됨`, 'success');
                            } else {
                                setGlobalNpcs(prev => [...prev, entity]);
                                showToast(`NPC '${entity.name}' 추가됨`, 'success');
                            }
                        }
                    };
                    window.addEventListener('message', handleMessage);
                    return () => window.removeEventListener('message', handleMessage);
                }, []);

                const updateNodeData = (key, value) => {
                    if (!selectedNodeId) return;
                    setNodes(p => p.map(n => n.id === selectedNodeId ? { ...n, data: { ...n.data, [key]: value } } : n));
                };

                // 아이콘 등 유틸리티 (기존 유지)
                const NODE_WIDTH = 200; const NODE_HEIGHT = 80;
                // ... (getConnectionPoints, createPath 등은 생략된 부분 없이 포함되어야 함)
                const getConnectionPoints = (s, t) => {
                    const sx = s.x + NODE_WIDTH/2, sy = s.y + NODE_HEIGHT/2, tx = t.x + NODE_WIDTH/2, ty = t.y + NODE_HEIGHT/2;
                    return { sx: sx < tx ? s.x + NODE_WIDTH : s.x, sy, tx: sx < tx ? t.x : t.x + NODE_WIDTH, ty };
                };
                // 단순화된 path 로직 사용 (위 코드 참고)

                const addNode = (type) => {
                    const id = `${type}-${Date.now()}`;
                    const newData = type === 'scene'
                        ? { title: '새 장면', description: '', background: '', trigger: '', npcs: [], enemies: [], rule: '', scene_type: 'normal' }
                        : { title: '새 엔딩', description: '', background: '' };
                    setNodes(p => [...p, { id, type, x: Math.random()*100+50, y: Math.random()*100+50, data: newData }]);
                };

                const deleteNode = (id) => {
                    if (id === 'start') return;
                    setNodes(p => p.filter(n => n.id !== id));
                    setConnections(p => p.filter(c => c.source !== id && c.target !== id));
                    if (selectedNodeId === id) setSelectedNodeId(null);
                };

                const handleGenerate = async () => { /* 기존 로직 유지, 필요시 validation 추가 가능 */ };

                // 렌더링
                return (
                    <div className="flex h-screen bg-black text-white font-sans overflow-hidden no-select">
                        {toast.show && (
                            <div className={`fixed top-4 left-1/2 -translate-x-1/2 z-[200] px-4 py-2 rounded shadow-lg font-bold animate-fade-in ${toast.type === 'error' ? 'bg-red-600' : 'bg-green-600'}`}>
                                {toast.message}
                            </div>
                        )}

                        <LoadingOverlay isOpen={isLoading} progress={progress} buildStatus={buildStatus} />
                        <NpcGeneratorModal
                            isOpen={isNpcGeneratorOpen}
                            onClose={() => setIsNpcGeneratorOpen(false)}
                            scenarioInfo={{
                                title: nodes.find(n => n.id === 'start')?.data.label || '',
                                summary: nodes.find(n => n.id === 'start')?.data.prologue || ''
                            }}
                        />

                        {/* 사이드바 */}
                        <div className="w-64 bg-gray-900 border-r border-gray-800 flex flex-col z-20 shadow-xl">
                            <div className="p-4 border-b border-gray-800"><h1 className="text-xl font-bold text-blue-400">Builder</h1></div>
                            <div className="p-4 space-y-3">
                                <button onClick={() => addNode('scene')} className="w-full py-2 bg-gray-800 border border-gray-700 rounded text-indigo-300 hover:bg-gray-700">씬 추가</button>
                                <button onClick={() => addNode('ending')} className="w-full py-2 bg-gray-800 border border-gray-700 rounded text-red-300 hover:bg-gray-700">엔딩 추가</button>
                                <button onClick={() => setIsNpcGeneratorOpen(true)} className="w-full py-2 bg-gray-800 border border-gray-700 rounded text-green-300 hover:bg-gray-700">NPC/적 생성</button>
                            </div>
                        </div>

                        {/* 캔버스 */}
                        <div ref={canvasRef} className="flex-1 relative bg-gray-950 overflow-hidden cursor-crosshair bg-dots-pattern"
                             onMouseMove={handleCanvasMouseMove} onMouseUp={handleCanvasMouseUp} onMouseDown={(e) => {
                                 if (e.button === 0 && !e.shiftKey) handleBackgroundClick(e);
                                 if (e.button === 1 || e.shiftKey) { setIsPanning(true); setPanStart({x:e.clientX-panOffset.x, y:e.clientY-panOffset.y}); }
                             }}
                             onWheel={(e) => { setZoom(Math.min(Math.max(zoom + (e.deltaY * -0.001), 0.25), 2)); }}>

                            <div style={{ transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoom})`, transformOrigin: '0 0', width: '100%', height: '100%', position: 'absolute' }}>
                                <svg className="absolute inset-0 w-full h-full pointer-events-none z-10" style={{ overflow: 'visible' }}>
                                    {connections.map(c => {
                                        const s = nodes.find(n => n.id === c.source), t = nodes.find(n => n.id === c.target);
                                        if(!s||!t) return null;
                                        const {sx,sy,tx,ty} = getConnectionPoints(s,t);
                                        return <path key={c.id} d={`M ${sx} ${sy} L ${tx} ${ty}`} className="connection-line" stroke="gray" strokeWidth="2" />;
                                    })}
                                    {connectingSourceId && (() => {
                                        const s = nodes.find(n => n.id === connectingSourceId);
                                        if(!s) return null;
                                        return <line x1={s.x+NODE_WIDTH/2} y1={s.y+NODE_HEIGHT/2} x2={mousePos.x} y2={mousePos.y} className="connecting-line" />;
                                    })()}
                                </svg>
                                {nodes.map(node => (
                                    <div key={node.id} style={{ left: node.x, top: node.y }} onMouseDown={(e) => handleMouseDownNode(e, node.id)}
                                         className={`absolute w-[200px] rounded-lg border-2 bg-gray-900 z-10 shadow-xl ${selectedNodeId === node.id ? 'border-white ring-2 ring-blue-500' : node.type==='start'?'border-blue-600':node.type==='ending'?'border-red-600':'border-indigo-600'}`}>
                                        <div className="p-2 text-sm font-bold flex justify-between">
                                            <span>{node.type}</span>
                                            <button onClick={(e)=>{e.stopPropagation(); setConnectingSourceId(node.id);}} className="hover:text-white text-gray-400"><Icon name="link" size={14}/></button>
                                        </div>
                                        <div className="p-3 text-xs text-gray-300 truncate">{node.data.title || node.data.label || '제목 없음'}</div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* 속성 패널 */}
                        <div className="w-80 bg-gray-900 border-l border-gray-800 overflow-y-auto z-20 p-6 space-y-4">
                            {selectedNodeId ? (() => {
                                const node = nodes.find(n => n.id === selectedNodeId);
                                if (!node) return null;
                                return (
                                    <>
                                        <h2 className="text-lg font-bold border-b border-gray-700 pb-2 mb-4">속성 편집</h2>

                                        {/* Start Node */}
                                        {node.type === 'start' && (
                                            <>
                                                <div><label className="text-xs text-gray-400">제목 <span className="text-red-500">*</span></label><input className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" value={node.data.label||''} onChange={e=>updateNodeData('label', e.target.value)} /></div>
                                                <div><label className="text-xs text-gray-400">배경 묘사 <span className="text-red-500">*</span></label><textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" rows={3} value={node.data.background||''} onChange={e=>updateNodeData('background', e.target.value)} /></div>
                                                <div><label className="text-xs text-blue-400">공개 프롤로그 <span className="text-red-500">*</span></label><textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" rows={5} value={node.data.prologue||''} onChange={e=>updateNodeData('prologue', e.target.value)} /></div>
                                                <div><label className="text-xs text-red-400">시스템 설정 <span className="text-red-500">*</span></label><textarea className="w-full bg-gray-900 border border-red-900 rounded p-2 text-sm" rows={5} value={node.data.gm_notes||''} onChange={e=>updateNodeData('gm_notes', e.target.value)} /></div>
                                            </>
                                        )}

                                        {/* Scene Node */}
                                        {node.type === 'scene' && (
                                            <>
                                                <div><label className="text-xs text-gray-400">장면 유형</label>
                                                    <select className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" value={node.data.scene_type||'normal'} onChange={e=>updateNodeData('scene_type',e.target.value)}>
                                                        <option value="normal">일반 (Normal)</option>
                                                        <option value="battle">전투 (Battle)</option>
                                                    </select>
                                                </div>
                                                <div><label className="text-xs text-gray-400">제목 <span className="text-red-500">*</span></label><input className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" value={node.data.title||''} onChange={e=>updateNodeData('title', e.target.value)} /></div>
                                                <div><label className="text-xs text-gray-400">배경 묘사 <span className="text-red-500">*</span></label><textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" rows={3} value={node.data.background||''} onChange={e=>updateNodeData('background', e.target.value)} /></div>
                                                <div><label className="text-xs text-gray-400">진입/진행 트리거 <span className="text-red-500">*</span></label><input className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" value={node.data.trigger||''} onChange={e=>updateNodeData('trigger', e.target.value)} placeholder="예: 문을 연다, 적을 처치한다" /></div>

                                                {/* 선택 사항 */}
                                                <div className="pt-4 border-t border-gray-800">
                                                    <h3 className="text-xs font-bold text-gray-500 mb-2">선택 사항 (Optional)</h3>
                                                    <div><label className="text-xs text-gray-400">추가 룰</label><textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" rows={2} value={node.data.rule||''} onChange={e=>updateNodeData('rule', e.target.value)} /></div>

                                                    <div className="mt-2">
                                                        <label className="text-xs text-green-400 flex justify-between">NPC 등장 <span className="cursor-pointer" onClick={()=>setIsNpcGeneratorOpen(true)}>+생성</span></label>
                                                        <div className="max-h-24 overflow-y-auto border border-gray-800 rounded p-1">{globalNpcs.map((n,i)=>(
                                                            <label key={i} className="flex items-center gap-2 text-xs p-1 hover:bg-gray-800"><input type="checkbox" checked={(node.data.npcs||[]).includes(n.name)} onChange={e=>updateNodeData('npcs', e.target.checked?[...(node.data.npcs||[]),n.name]:(node.data.npcs||[]).filter(x=>x!==n.name))} />{n.name}</label>
                                                        ))}</div>
                                                    </div>

                                                    <div className="mt-2">
                                                        <label className="text-xs text-red-400 flex justify-between">적(Enemy) 등장 <span className="cursor-pointer" onClick={()=>setIsNpcGeneratorOpen(true)}>+생성</span></label>
                                                        <div className="max-h-24 overflow-y-auto border border-gray-800 rounded p-1">{globalEnemies.map((e,i)=>(
                                                            <label key={i} className="flex items-center gap-2 text-xs p-1 hover:bg-gray-800"><input type="checkbox" checked={(node.data.enemies||[]).includes(e.name)} onChange={ev=>updateNodeData('enemies', ev.target.checked?[...(node.data.enemies||[]),e.name]:(node.data.enemies||[]).filter(x=>x!==e.name))} />{e.name} (LV.{e.difficulty})</label>
                                                        ))}</div>
                                                    </div>
                                                </div>
                                            </>
                                        )}

                                        {/* Ending Node */}
                                        {node.type === 'ending' && (
                                            <>
                                                <div><label className="text-xs text-gray-400">제목</label><input className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" value={node.data.title||''} onChange={e=>updateNodeData('title', e.target.value)} /></div>
                                                <div><label className="text-xs text-gray-400">배경 묘사 <span className="text-red-500">*</span></label><textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" rows={3} value={node.data.background||''} onChange={e=>updateNodeData('background', e.target.value)} /></div>
                                                <div><label className="text-xs text-gray-400">엔딩 문구 <span className="text-red-500">*</span></label><textarea className="w-full bg-gray-800 border border-gray-700 rounded p-2 text-sm" rows={5} value={node.data.description||''} onChange={e=>updateNodeData('description', e.target.value)} /></div>
                                            </>
                                        )}

                                        <button onClick={()=>deleteNode(node.id)} className="w-full py-2 bg-red-900/50 hover:bg-red-900 text-red-200 rounded mt-4 text-xs">노드 삭제</button>
                                    </>
                                );
                            })() : <div className="text-center text-gray-500 mt-10">노드를 선택하세요</div>}
                        </div>
                    </div>
                );
            }
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<ScenarioBuilder />);
        } catch (e) { console.error(e); }
    </script>
    {% endraw %}
</body>
</html>